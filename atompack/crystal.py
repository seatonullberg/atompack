import copy
import json
from collections.abc import MutableSequence
from typing import List, Tuple, Union

import numpy as np
from scipy.spatial.transform import Rotation

from atompack.atom import Atom
from atompack.bond import Bond
from atompack.constants import DEG90, DEG120
from atompack.spacegroup import Spacegroup
from atompack.topology import Topology


class Basis(MutableSequence):
    """Crystalline basis.

    Args:
        basis: List of specie/site pairs.

    Example:
        >>> from atompack.crystal import Basis
        >>> import numpy as np
        >>>
        >>> # primitive basis of iron atoms
        >>> basis = Basis.primitive("Fe")
        >>> assert len(basis) == 1
        >>>
        >>> specie, site = basis[0]
        >>> assert specie == "Fe"
        >>> assert np.array_equal(site, np.zeros(3))
    """

    def __init__(self, basis: List[Tuple[str, np.ndarray]]) -> None:
        for _, site in basis:
            if max(site) > 1 or min(site) < -1:
                raise ValueError("basis sites must be represented in fractional coordinates")
        self._basis = basis

    ########################################
    #    MutableSequence Implementation    #
    ########################################

    def __getitem__(self, index: int) -> Tuple[str, np.ndarray]:
        return self._basis[index]

    def __setitem__(self, index: int, value: Tuple[str, np.ndarray]) -> None:
        self._basis[index] = value

    def __delitem__(self, index: int) -> None:
        del self._basis[index]

    def __len__(self) -> int:
        return len(self._basis)

    def insert(self, index: int, value: Tuple[str, np.ndarray]) -> None:
        self._basis.insert(index, value)

    ######################
    #    Constructors    #
    ######################

    @classmethod
    def primitive(cls, specie: str) -> 'Basis':
        """Returns a primitive basis."""
        return cls([(specie, np.zeros(3))])

    @classmethod
    def from_json(cls, s) -> 'Basis':
        """Initializes from a JSON string."""
        data = json.loads(s)
        basis = []
        for entry in data:
            specie = entry["specie"]
            site = np.array(entry["site"])
            basis.append((specie, site))
        return cls(basis)

    ########################
    #    Public Methods    #
    ########################

    def apply_spacegroup(self, spacegroup: Spacegroup) -> List[Tuple[str, np.ndarray]]:
        """Returns a list of specie/site pairs generated by applying a spacegroup's
        symmetry operations to the atomic basis."""
        # search tolerance
        tolerance = 1E-6

        # skip process if no sites exist
        if len(self) == 0:
            return []

        res = [self._basis[0]]
        # iterate over basis
        for specie, site in self._basis:
            # iterate through the spacegroup's general position expressions
            for genpos in spacegroup.genpos:
                # convert string expressions to arrays
                genpos = "[{}]".format(genpos)
                x, y, z = site[0], site[1], site[2]
                new_site = np.array(eval(genpos))
                # wrap all values between 0-1
                for i in range(len(new_site)):
                    if new_site[i] < 0:
                        new_site[i] += 1
                # check if equivalent site exists
                is_occupied = False
                for _, _site in res:
                    if np.linalg.norm(new_site - _site) < tolerance:
                        is_occupied = True
                # store unique sites
                if not is_occupied:
                    res.append((specie, new_site))
        return res

    def to_json(self) -> str:
        """Returns a JSON serialized representation."""
        _basis = self._basis.copy()
        _basis = [{"specie": specie, "site": site.tolist()} for specie, site in _basis]
        return json.dumps(_basis)


class LatticeParameters(object):
    """Edge lengths and angles which define a lattice.
    
    Args:
        a: Length of the x lattice vector.
        b: Length of the y lattice vector.
        c: Length of the z lattice vector.
        alpha: Angle between the y and z directions (radians).
        beta: Angle between the x and z directions (radians).
        gamma: Angle between the x and y directions (radians).

    Example:
        >>> from atompack.crystal import LatticeParameters
        >>> import numpy as np
        >>>
        >>> # cubic lattice parameters
        >>> params = LatticeParameters.cubic(10)
        >>> assert params.a == params.b == params.c == 10
        >>> assert params.alpha == params.beta == params.gamma == np.pi / 2
    """

    def __init__(self, a: float, b: float, c: float, alpha: float, beta: float, gamma: float) -> None:
        self.a = a
        self.b = b
        self.c = c
        self.alpha = alpha
        self.beta = beta
        self.gamma = gamma

    ######################
    #    Constructors    #
    ######################

    @classmethod
    def triclinic(cls, a, b, c, alpha, beta, gamma) -> 'LatticeParameters':
        """Initializes with triclinic constraints."""
        return cls(a, b, c, alpha, beta, gamma)

    @classmethod
    def monoclinic(cls, a, b, c, beta) -> 'LatticeParameters':
        """Initializes with monoclinic constraints."""
        return cls(a, b, c, DEG90, beta, DEG90)

    @classmethod
    def orthorhombic(cls, a, b, c) -> 'LatticeParameters':
        """Initializes with orthorhombic constraints."""
        return cls(a, b, c, DEG90, DEG90, DEG90)

    @classmethod
    def tetragonal(cls, a, c) -> 'LatticeParameters':
        """Initializes with tetragonal constraints."""
        return cls(a, a, c, DEG90, DEG90, DEG90)

    @classmethod
    def trigonal(cls, a, c) -> 'LatticeParameters':
        """Initializes with trigonal constraints."""
        return cls(a, a, c, DEG90, DEG90, DEG120)

    @classmethod
    def rhombohedral(cls, a, alpha) -> 'LatticeParameters':
        """Initializes with rhombohedral constraints."""
        return cls(a, a, a, alpha, alpha, alpha)

    @classmethod
    def hexagonal(cls, a, c) -> 'LatticeParameters':
        """Initializes with hexagonal constraints."""
        return cls(a, a, c, DEG90, DEG90, DEG120)

    @classmethod
    def cubic(cls, a) -> 'LatticeParameters':
        """Initializes with cubic constraints."""
        return cls(a, a, a, DEG90, DEG90, DEG90)

    @classmethod
    def from_json(cls, s: str) -> 'LatticeParameters':
        """Initializes from a JSON string."""
        data = json.loads(s)
        data = {k: float(v) for k, v in data.items()}
        return cls(**data)

    ####################
    #    Properties    #
    ####################

    @property
    def metric_tensor(self) -> np.ndarray:
        """Returns the metric tensor defined by the lattice parameters."""
        return np.array([[self.a * self.a, self.a * self.b * np.cos(self.gamma), self.a * self.c * np.cos(self.beta)],
                         [self.a * self.b * np.cos(self.gamma), self.b * self.b, self.b * self.c * np.cos(self.alpha)],
                         [self.a * self.c * np.cos(self.beta), self.b * self.c * np.cos(self.alpha), self.c * self.c]])

    ########################
    #    Public Methods    #
    ########################

    def to_json(self) -> str:
        """Returns the JSON serialized representation."""
        return json.dumps({
            "a": self.a,
            "b": self.b,
            "c": self.c,
            "alpha": self.alpha,
            "beta": self.beta,
            "gamma": self.gamma
        })


class Orientation(Rotation):
    """Representation of a crystallographic orientation.
    This class inherits from `scipy.spatial.transform.Rotation`.
    """

    ######################
    #    Constructors    #
    ######################

    @classmethod
    def from_miller_indices(cls, hkl: Tuple[int, int, int], uvw: Tuple[int, int, int]) -> 'Orientation':
        """Initialize from Miller Indices.
        
        Args:
            hkl: Indices of the plane.
            uvw: Indices of the direction.
        """
        pass

    ########################
    #    Public Methods    #
    ########################

    def as_miller_indices(self) -> Tuple[Tuple[int, int, int], Tuple[int, int, int]]:
        """Represent as Miller Indices."""
        pass


class MillerIndex(object):
    """Representation of a Miller index."""

    def __init__(self, hkl: Tuple[int, int, int]) -> None:
        self.hkl = hkl

    def plane_intercepts(self, cell: np.ndarray) -> np.ndarray:
        """Returns the intercept coordinates."""
        recip = self._reciprocal()
        bounds = np.linalg.norm(cell, axis=1)
        directions = cell / bounds[:,None]
        return directions * recip[:,None] * bounds

    def _reciprocal(self) -> np.ndarray:
        return np.array([1 / index if index > 0 else np.inf for index in self.hkl])


class Plane(object):
    """Representation of a crystallographic plane."""

    ######################
    #    Constructors    #
    ######################

    @classmethod
    def from_miller_indices(cls, hkl: Tuple[int, int, int]) -> 'Plane':
        """Initialize from Miller Indices."""
        pass


class UnitCell(Topology):
    """Minimal representation of a crystalline structure.
    
    Args:
        basis: Atomic basis.
        lattice_parameters: Lattice parameters object.
        spacegroup: Spacegroup object.

    Example:
        >>> # primitive basis of iron
        >>> basis = Basis.primitive("Fe")
        >>> 
        >>> # cubic lattice parameters
        >>> lattparams = LatticeParameters.cubic(2.85)
        >>> 
        >>> # BCC spacegroup
        >>> spg = Spacegroup("I m -3 m")
        >>> 
        >>> # build the unit cell
        >>> unit_cell = UnitCell(basis, lattparams, spg)
        >>> assert len(unit_cell.atoms) == 2
    """

    def __init__(
        self,
        basis: Basis,
        lattice_parameters: LatticeParameters,
        spacegroup: Spacegroup,
        _build: bool = True,
    ) -> None:
        # initialize superclass
        super().__init__()
        # set attributes
        self._basis = basis
        self._lattice_parameters = lattice_parameters
        self._spacegroup = spacegroup
        # build the unit cell
        if _build:
            self._build()

    ######################
    #    Constructors    #
    ######################

    @classmethod
    def from_json(cls, s: str) -> 'UnitCell':
        """Initializes from a JSON string."""
        topology = Topology.from_json(s)
        data = json.loads(s)
        basis = Basis.from_json(json.dumps(data["basis"]))
        params = LatticeParameters.from_json(json.dumps(data["lattice_parameters"]))
        spg = Spacegroup(int(data["spacegroup"]))
        # initialize unit cell without placing atoms
        res = cls(basis, params, spg, _build=False)
        res._graph = topology._graph
        return res

    ####################
    #    Properties    #
    ####################

    @property
    def basis(self) -> Basis:
        """Returns the basis."""
        return self._basis

    @property
    def lattice_parameters(self) -> LatticeParameters:
        """Returns the lattice parameters."""
        return self._lattice_parameters

    @property
    def lattice_vectors(self) -> np.ndarray:
        """Returns the lattice vectors."""
        return np.sqrt(np.abs(self.lattice_parameters.metric_tensor))

    @property
    def spacegroup(self) -> Spacegroup:
        """Returns the spacegroup."""
        return self._spacegroup

    ########################
    #    Public Methods    #
    ########################

    def to_json(self) -> str:
        """Returns the JSON serialized representation."""
        topology_data = json.loads(super().to_json())
        return json.dumps({
            "basis": json.loads(self.basis.to_json()),
            "lattice_parameters": json.loads(self.lattice_parameters.to_json()),
            "spacegroup": self.spacegroup.international_number,
            "atoms": topology_data["atoms"],
            "bonds": topology_data["bonds"],
        })

    #########################
    #    Private Methods    #
    #########################

    def _build(self) -> None:
        for specie, site in self.basis.apply_spacegroup(self.spacegroup):
            position = site * np.linalg.norm(self.lattice_vectors, axis=0)
            self.insert_atom(Atom(specie, position))


class Crystal(Topology):
    """Atomic structure with long range order.
    
    Args:
        unit_cell: Minimal representation of a crystalline structure.
    """

    def __init__(
        self,
        unit_cell: UnitCell,
        _build: bool = True,
    ) -> None:
        # initialize superclass
        super().__init__()
        # initialize private attributes
        self._cut_plane: Optional[Plane] = None
        self._extent: Optional[Tuple[int, int, int]] = None
        self._orientation: Optional[Orientation] = None
        self._orthogonalize: Optional[bool] = None
        self._projection_plane: Optional[Plane] = None
        self._transformation_matrix: Optional[np.ndarray] = None
        # build the crystal
        self._unit_cell = unit_cell
        if _build:
            self._lattice_vectors = self._unit_cell.lattice_vectors.copy()
            for atom in self._unit_cell.atoms:
                self.insert_atom(copy.deepcopy(atom))
            for bond in self._unit_cell.bonds:
                self.insert_bond(copy.deepcopy(bond))

    ######################
    #    Constructors    #
    ######################

    @classmethod
    def from_json(cls, s: str) -> 'Crystal':
        """Initializes from a JSON string."""
        topology = Topology.from_json(s)
        data = json.loads(s)
        unit_cell = UnitCell.from_json(json.dumps(data["unit_cell"]))
        res = cls(unit_cell, _build=False)
        res._lattice_vectors = np.array(data["lattice_vectors"])
        res._graph = topology._graph
        return res

    ####################
    #    Properties    #
    ####################

    @property
    def lattice_vectors(self):
        """Returns the lattice vectors."""
        return self._lattice_vectors

    @property
    def unit_cell(self):
        """Returns the unit cell."""
        return self._unit_cell

    ########################
    #    Public Methods    #
    ########################

    def general_transform(self, transformation: np.ndarray) -> 'Crystal':
        """Applies a general transformation matrix to the crystal.
        Mutates the crystal and returns a reference to itself to enable method chaining.

        Args:
            transformation: Transformation matrix.

        Note:
            The transform is not applied until the `finish` method is called.
        """
        raise NotImplementedError
        self._transformation_matrix = transformation
        return self

    def supercell(self, extent: Tuple[int, int, int]) -> 'Crystal':
        """Creates a supercell by duplicating the crystal in 3 dimensions.
        Mutates the crystal and returns a reference to itself to enable method chaining.

        Args:
            extent: Number of repeat units in each direction.

        Note:
            The transform is not applied until the `finish` method is called.
        """
        self._extent = extent
        return self

    def orient(self, orientation: Orientation) -> 'Crystal':
        """Changes the crystal's orientation.
        Mutates the crystal and returns a reference to itself to enable method chaining.

        Args:
            orientation: Crystallographic orientation.

        Note:
            The transform is not applied until the `finish` method is called.
        """
        raise NotImplementedError
        self._orientation = orientation
        return self

    def project(self, plane: Plane, orthogonalize: bool = False) -> 'Crystal':
        """Projects the crystal onto a plane.
        Mutates the crystal and returns a reference to itself to enable method chaining.

        Args:
            plane: Projection plane.
            orthogonalize: Determines whether or not the projection is represented as an orthogonal lattice.

        Note:
            The transform is not applied until the `finish` method is called.
            Setting `orthogonalize` to True may result in very large structures for acute projections.
        """
        raise NotImplementedError
        self._projection_plane = plane
        self._orthogonalize = orthogonalize
        return self

    def cut(self, plane: Plane) -> 'Crystal':
        """Cuts the crystal along a plane.
        Mutates the crystal and returns a reference to itself to enable method chaining.

        Args:
            plane: Plane to cut along.

        Note:
            The transform is not applied until the `finish` method is called.
        """
        raise NotImplementedError
        self._cut_plane = plane
        return self

    def finish(self) -> None:
        """Applies all active transformations to the crystal."""
        # call underlying implementations
        # TODO: determine best order
        self._project()
        self._general_transform()
        self._cut()
        self._orient()
        self._supercell()
        # reset attributes
        self._reset_attributes()

    def reset(self) -> None:
        """Undoes all transformations."""
        super().__init__()
        self._reset_attributes()
        self._lattice_vectors = self.unit_cell.lattice_vectors.copy()
        for atom in self.unit_cell.atoms:
            self.insert_atom(copy.deepcopy(atom))
        for bond in self.unit_cell.bonds:
            self.insert_bond(copy.deepcopy(bond))

    def to_json(self) -> str:
        """Returns the JSON serialized representation."""
        topology_data = json.loads(super().to_json())
        return json.dumps({
            "unit_cell": json.loads(self.unit_cell.to_json()),
            "lattice_vectors": self.lattice_vectors.tolist(),
            "atoms": topology_data["atoms"],
            "bonds": topology_data["bonds"],
        })

    #########################
    #    Private Methods    #
    #########################

    def _reset_attributes(self) -> None:
        self._cut_plane = None
        self._extent = None
        self._orientation = None
        self._orthogonalize = None
        self._projection_plane = None
        self._transformation_matrix = None

    def _general_transform(self) -> None:
        if self._transformation_matrix is None:
            return

    def _supercell(self) -> None:
        if self._extent is None:
            return

        existing_atoms = self.atoms.copy()
        for x in range(self._extent[0]):
            for y in range(self._extent[1]):
                for z in range(self._extent[2]):
                    if x == y == z == 0:
                        continue
                    offset = np.matmul(np.array([x, y, z]), self.lattice_vectors)
                    for atom in existing_atoms:
                        _atom = copy.deepcopy(atom)
                        _atom.position += offset
                        self.insert_atom(_atom)
        self._lattice_vectors *= self._extent

    def _orient(self) -> None:
        if self._orientation is None:
            return

    def _project(self) -> None:
        if self._projection_plane is None:
            return

    def _cut(self) -> None:
        if self._cut_plane is None:
            return
