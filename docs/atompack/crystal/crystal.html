<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>atompack.crystal.crystal API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>atompack.crystal.crystal</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import copy
import json
from typing import List, Optional, Tuple

import numpy as np

from atompack.atom import Atom
from atompack.bond import Bond
from atompack.crystal.components import Basis, LatticeParameters
from atompack.crystal.spatial import Orientation, Plane
from atompack.symmetry import Spacegroup
from atompack.topology import Topology


class UnitCell(Topology):
    &#34;&#34;&#34;Minimal representation of a crystalline structure.
    
    Args:
        basis: Atomic basis.
        lattice_parameters: Lattice parameters object.
        spacegroup: Spacegroup object.

    Example:
        &gt;&gt;&gt; # primitive basis of iron
        &gt;&gt;&gt; basis = Basis.primitive(&#34;Fe&#34;)
        &gt;&gt;&gt; 
        &gt;&gt;&gt; # cubic lattice parameters
        &gt;&gt;&gt; lattparams = LatticeParameters.cubic(2.85)
        &gt;&gt;&gt; 
        &gt;&gt;&gt; # BCC spacegroup
        &gt;&gt;&gt; spg = Spacegroup(&#34;I m -3 m&#34;)
        &gt;&gt;&gt; 
        &gt;&gt;&gt; # build the unit cell
        &gt;&gt;&gt; unit_cell = UnitCell(basis, lattparams, spg)
        &gt;&gt;&gt; assert len(unit_cell.atoms) == 2
    &#34;&#34;&#34;

    def __init__(
        self,
        basis: Basis,
        lattice_parameters: LatticeParameters,
        spacegroup: Spacegroup,
        _build: bool = True,
    ) -&gt; None:
        # initialize superclass
        super().__init__()
        # set attributes
        self._basis = basis
        self._lattice_parameters = lattice_parameters
        self._spacegroup = spacegroup
        # build the unit cell
        if _build:
            self._build()

    ######################
    #    Constructors    #
    ######################

    @classmethod
    def from_json(cls, s: str) -&gt; &#39;UnitCell&#39;:
        &#34;&#34;&#34;Initializes from a JSON string.&#34;&#34;&#34;
        topology = Topology.from_json(s)
        data = json.loads(s)
        basis = Basis.from_json(json.dumps(data[&#34;basis&#34;]))
        params = LatticeParameters.from_json(json.dumps(data[&#34;lattice_parameters&#34;]))
        spg = Spacegroup(int(data[&#34;spacegroup&#34;]))
        # initialize unit cell without placing atoms
        res = cls(basis, params, spg, _build=False)
        res._graph = topology._graph
        return res

    ####################
    #    Properties    #
    ####################

    @property
    def basis(self) -&gt; Basis:
        &#34;&#34;&#34;Returns the basis.&#34;&#34;&#34;
        return self._basis

    @property
    def lattice_parameters(self) -&gt; LatticeParameters:
        &#34;&#34;&#34;Returns the lattice parameters.&#34;&#34;&#34;
        return self._lattice_parameters

    @property
    def lattice_vectors(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns the lattice vectors.&#34;&#34;&#34;
        return np.sqrt(np.abs(self.lattice_parameters.metric_tensor))

    @property
    def spacegroup(self) -&gt; Spacegroup:
        &#34;&#34;&#34;Returns the spacegroup.&#34;&#34;&#34;
        return self._spacegroup

    ########################
    #    Public Methods    #
    ########################

    def to_json(self) -&gt; str:
        &#34;&#34;&#34;Returns the JSON serialized representation.&#34;&#34;&#34;
        topology_data = json.loads(super().to_json())
        return json.dumps({
            &#34;basis&#34;: json.loads(self.basis.to_json()),
            &#34;lattice_parameters&#34;: json.loads(self.lattice_parameters.to_json()),
            &#34;spacegroup&#34;: self.spacegroup.international_number,
            &#34;atoms&#34;: topology_data[&#34;atoms&#34;],
            &#34;bonds&#34;: topology_data[&#34;bonds&#34;],
        })

    #########################
    #    Private Methods    #
    #########################

    def _build(self) -&gt; None:
        for specie, site in self.basis.apply_spacegroup(self.spacegroup):
            position = site * np.linalg.norm(self.lattice_vectors, axis=0)
            self.insert_atoms(Atom(specie, position))


class Crystal(Topology):
    &#34;&#34;&#34;Atomic structure with long range order.
    
    Args:
        unit_cell: Minimal representation of a crystalline structure.
    &#34;&#34;&#34;

    def __init__(
        self,
        unit_cell: UnitCell,
        _build: bool = True,
    ) -&gt; None:
        # initialize superclass
        super().__init__()
        # initialize private attributes
        self._cut_plane: Optional[Plane] = None
        self._extent: Optional[Tuple[int, int, int]] = None
        self._orientation: Optional[Orientation] = None
        self._orthogonalize: Optional[bool] = None
        self._projection_plane: Optional[Plane] = None
        self._transformation_matrix: Optional[np.ndarray] = None
        # build the crystal
        self._unit_cell = unit_cell
        if _build:
            self._lattice_vectors = self._unit_cell.lattice_vectors.copy()
            for atom in self._unit_cell.atoms:
                self.insert_atoms(copy.deepcopy(atom))
            for bond in self._unit_cell.bonds:
                self.insert_bond(copy.deepcopy(bond))

    ######################
    #    Constructors    #
    ######################

    @classmethod
    def from_json(cls, s: str) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes from a JSON string.&#34;&#34;&#34;
        topology = Topology.from_json(s)
        data = json.loads(s)
        unit_cell = UnitCell.from_json(json.dumps(data[&#34;unit_cell&#34;]))
        res = cls(unit_cell, _build=False)
        res._lattice_vectors = np.array(data[&#34;lattice_vectors&#34;])
        res._graph = topology._graph
        return res

    ####################
    #    Properties    #
    ####################

    @property
    def lattice_vectors(self):
        &#34;&#34;&#34;Returns the lattice vectors.&#34;&#34;&#34;
        return self._lattice_vectors

    @property
    def unit_cell(self):
        &#34;&#34;&#34;Returns the unit cell.&#34;&#34;&#34;
        return self._unit_cell

    ########################
    #    Public Methods    #
    ########################

    def general_transform(self, transformation: np.ndarray) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Applies a general transformation matrix to the crystal.
        Mutates the crystal and returns a reference to itself to enable method chaining.

        Args:
            transformation: Transformation matrix.

        Note:
            The transform is not applied until the `finish` method is called.
        &#34;&#34;&#34;
        raise NotImplementedError
        self._transformation_matrix = transformation
        return self

    def supercell(self, extent: Tuple[int, int, int]) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Creates a supercell by duplicating the crystal in 3 dimensions.
        Mutates the crystal and returns a reference to itself to enable method chaining.

        Args:
            extent: Number of repeat units in each direction.

        Note:
            The transform is not applied until the `finish` method is called.
        &#34;&#34;&#34;
        self._extent = extent
        return self

    def orient(self, orientation: Orientation) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Changes the crystal&#39;s orientation.
        Mutates the crystal and returns a reference to itself to enable method chaining.

        Args:
            orientation: Crystallographic orientation.

        Note:
            The transform is not applied until the `finish` method is called.
        &#34;&#34;&#34;
        raise NotImplementedError
        self._orientation = orientation
        return self

    def project(self, plane: Plane, orthogonalize: bool = False) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Projects the crystal onto a plane.
        Mutates the crystal and returns a reference to itself to enable method chaining.

        Args:
            plane: Projection plane.
            orthogonalize: Determines whether or not the projection is represented as an orthogonal lattice.

        Note:
            The transform is not applied until the `finish` method is called.
            Setting `orthogonalize` to True may result in very large structures for acute projections.
        &#34;&#34;&#34;
        raise NotImplementedError
        self._projection_plane = plane
        self._orthogonalize = orthogonalize
        return self

    def cut(self, plane: Plane) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Cuts the crystal along a plane.
        Mutates the crystal and returns a reference to itself to enable method chaining.

        Args:
            plane: Crystallographic plane to cut along.

        Note:
            The transform is not applied until the `finish` method is called.
        &#34;&#34;&#34;
        self._cut_plane = plane
        return self

    def finish(self) -&gt; None:
        &#34;&#34;&#34;Applies all active transformations to the crystal.&#34;&#34;&#34;
        # call underlying implementations
        # TODO: determine best order
        self._project()
        self._general_transform()
        self._orient()
        self._supercell()
        self._cut()
        # reset attributes
        self._reset_attributes()

    def reset(self) -&gt; None:
        &#34;&#34;&#34;Undoes all transformations.&#34;&#34;&#34;
        super().__init__()
        self._reset_attributes()
        self._lattice_vectors = self.unit_cell.lattice_vectors.copy()
        for atom in self.unit_cell.atoms:
            self.insert_atoms(copy.deepcopy(atom))
        for bond in self.unit_cell.bonds:
            self.insert_bond(copy.deepcopy(bond))

    def to_json(self) -&gt; str:
        &#34;&#34;&#34;Returns the JSON serialized representation.&#34;&#34;&#34;
        topology_data = json.loads(super().to_json())
        return json.dumps({
            &#34;unit_cell&#34;: json.loads(self.unit_cell.to_json()),
            &#34;lattice_vectors&#34;: self.lattice_vectors.tolist(),
            &#34;atoms&#34;: topology_data[&#34;atoms&#34;],
            &#34;bonds&#34;: topology_data[&#34;bonds&#34;],
        })

    #########################
    #    Private Methods    #
    #########################

    def _reset_attributes(self) -&gt; None:
        self._cut_plane = None
        self._extent = None
        self._orientation = None
        self._orthogonalize = None
        self._projection_plane = None
        self._transformation_matrix = None

    def _general_transform(self) -&gt; None:
        if self._transformation_matrix is None:
            return

    def _supercell(self) -&gt; None:
        if self._extent is None:
            return

        existing_atoms = self.atoms.copy()
        for x in range(self._extent[0]):
            for y in range(self._extent[1]):
                for z in range(self._extent[2]):
                    if x == y == z == 0:
                        continue
                    offset = np.matmul(np.array([x, y, z]), self.lattice_vectors)
                    for atom in existing_atoms:
                        _atom = copy.deepcopy(atom)
                        _atom.position += offset
                        self.insert_atoms(_atom)
        self._lattice_vectors *= self._extent

    def _orient(self) -&gt; None:
        if self._orientation is None:
            return

    def _project(self) -&gt; None:
        if self._projection_plane is None:
            return

    def _cut(self) -&gt; None:
        if self._cut_plane is None:
            return

        removal_indices = []
        intercepts = self._cut_plane.plane_intercepts(self.lattice_vectors)
        print(intercepts)
        print()
        center = intercepts / 2
        print(center)
        print()
        for i, atom in enumerate(self.atoms):
            for j, intercept in enumerate(intercepts):
                search_vector = atom.position - center
                print(search_vector)
                print()
                if min(search_vector) &gt; 0:
                    removal_indices.append(i)
        self.remove_atoms(*removal_indices)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="atompack.crystal.crystal.Crystal"><code class="flex name class">
<span>class <span class="ident">Crystal</span></span>
<span>(</span><span>unit_cell: <a title="atompack.crystal.crystal.UnitCell" href="#atompack.crystal.crystal.UnitCell">UnitCell</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Atomic structure with long range order.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>unit_cell</code></strong></dt>
<dd>Minimal representation of a crystalline structure.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Crystal(Topology):
    &#34;&#34;&#34;Atomic structure with long range order.
    
    Args:
        unit_cell: Minimal representation of a crystalline structure.
    &#34;&#34;&#34;

    def __init__(
        self,
        unit_cell: UnitCell,
        _build: bool = True,
    ) -&gt; None:
        # initialize superclass
        super().__init__()
        # initialize private attributes
        self._cut_plane: Optional[Plane] = None
        self._extent: Optional[Tuple[int, int, int]] = None
        self._orientation: Optional[Orientation] = None
        self._orthogonalize: Optional[bool] = None
        self._projection_plane: Optional[Plane] = None
        self._transformation_matrix: Optional[np.ndarray] = None
        # build the crystal
        self._unit_cell = unit_cell
        if _build:
            self._lattice_vectors = self._unit_cell.lattice_vectors.copy()
            for atom in self._unit_cell.atoms:
                self.insert_atoms(copy.deepcopy(atom))
            for bond in self._unit_cell.bonds:
                self.insert_bond(copy.deepcopy(bond))

    ######################
    #    Constructors    #
    ######################

    @classmethod
    def from_json(cls, s: str) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes from a JSON string.&#34;&#34;&#34;
        topology = Topology.from_json(s)
        data = json.loads(s)
        unit_cell = UnitCell.from_json(json.dumps(data[&#34;unit_cell&#34;]))
        res = cls(unit_cell, _build=False)
        res._lattice_vectors = np.array(data[&#34;lattice_vectors&#34;])
        res._graph = topology._graph
        return res

    ####################
    #    Properties    #
    ####################

    @property
    def lattice_vectors(self):
        &#34;&#34;&#34;Returns the lattice vectors.&#34;&#34;&#34;
        return self._lattice_vectors

    @property
    def unit_cell(self):
        &#34;&#34;&#34;Returns the unit cell.&#34;&#34;&#34;
        return self._unit_cell

    ########################
    #    Public Methods    #
    ########################

    def general_transform(self, transformation: np.ndarray) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Applies a general transformation matrix to the crystal.
        Mutates the crystal and returns a reference to itself to enable method chaining.

        Args:
            transformation: Transformation matrix.

        Note:
            The transform is not applied until the `finish` method is called.
        &#34;&#34;&#34;
        raise NotImplementedError
        self._transformation_matrix = transformation
        return self

    def supercell(self, extent: Tuple[int, int, int]) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Creates a supercell by duplicating the crystal in 3 dimensions.
        Mutates the crystal and returns a reference to itself to enable method chaining.

        Args:
            extent: Number of repeat units in each direction.

        Note:
            The transform is not applied until the `finish` method is called.
        &#34;&#34;&#34;
        self._extent = extent
        return self

    def orient(self, orientation: Orientation) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Changes the crystal&#39;s orientation.
        Mutates the crystal and returns a reference to itself to enable method chaining.

        Args:
            orientation: Crystallographic orientation.

        Note:
            The transform is not applied until the `finish` method is called.
        &#34;&#34;&#34;
        raise NotImplementedError
        self._orientation = orientation
        return self

    def project(self, plane: Plane, orthogonalize: bool = False) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Projects the crystal onto a plane.
        Mutates the crystal and returns a reference to itself to enable method chaining.

        Args:
            plane: Projection plane.
            orthogonalize: Determines whether or not the projection is represented as an orthogonal lattice.

        Note:
            The transform is not applied until the `finish` method is called.
            Setting `orthogonalize` to True may result in very large structures for acute projections.
        &#34;&#34;&#34;
        raise NotImplementedError
        self._projection_plane = plane
        self._orthogonalize = orthogonalize
        return self

    def cut(self, plane: Plane) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Cuts the crystal along a plane.
        Mutates the crystal and returns a reference to itself to enable method chaining.

        Args:
            plane: Crystallographic plane to cut along.

        Note:
            The transform is not applied until the `finish` method is called.
        &#34;&#34;&#34;
        self._cut_plane = plane
        return self

    def finish(self) -&gt; None:
        &#34;&#34;&#34;Applies all active transformations to the crystal.&#34;&#34;&#34;
        # call underlying implementations
        # TODO: determine best order
        self._project()
        self._general_transform()
        self._orient()
        self._supercell()
        self._cut()
        # reset attributes
        self._reset_attributes()

    def reset(self) -&gt; None:
        &#34;&#34;&#34;Undoes all transformations.&#34;&#34;&#34;
        super().__init__()
        self._reset_attributes()
        self._lattice_vectors = self.unit_cell.lattice_vectors.copy()
        for atom in self.unit_cell.atoms:
            self.insert_atoms(copy.deepcopy(atom))
        for bond in self.unit_cell.bonds:
            self.insert_bond(copy.deepcopy(bond))

    def to_json(self) -&gt; str:
        &#34;&#34;&#34;Returns the JSON serialized representation.&#34;&#34;&#34;
        topology_data = json.loads(super().to_json())
        return json.dumps({
            &#34;unit_cell&#34;: json.loads(self.unit_cell.to_json()),
            &#34;lattice_vectors&#34;: self.lattice_vectors.tolist(),
            &#34;atoms&#34;: topology_data[&#34;atoms&#34;],
            &#34;bonds&#34;: topology_data[&#34;bonds&#34;],
        })

    #########################
    #    Private Methods    #
    #########################

    def _reset_attributes(self) -&gt; None:
        self._cut_plane = None
        self._extent = None
        self._orientation = None
        self._orthogonalize = None
        self._projection_plane = None
        self._transformation_matrix = None

    def _general_transform(self) -&gt; None:
        if self._transformation_matrix is None:
            return

    def _supercell(self) -&gt; None:
        if self._extent is None:
            return

        existing_atoms = self.atoms.copy()
        for x in range(self._extent[0]):
            for y in range(self._extent[1]):
                for z in range(self._extent[2]):
                    if x == y == z == 0:
                        continue
                    offset = np.matmul(np.array([x, y, z]), self.lattice_vectors)
                    for atom in existing_atoms:
                        _atom = copy.deepcopy(atom)
                        _atom.position += offset
                        self.insert_atoms(_atom)
        self._lattice_vectors *= self._extent

    def _orient(self) -&gt; None:
        if self._orientation is None:
            return

    def _project(self) -&gt; None:
        if self._projection_plane is None:
            return

    def _cut(self) -&gt; None:
        if self._cut_plane is None:
            return

        removal_indices = []
        intercepts = self._cut_plane.plane_intercepts(self.lattice_vectors)
        print(intercepts)
        print()
        center = intercepts / 2
        print(center)
        print()
        for i, atom in enumerate(self.atoms):
            for j, intercept in enumerate(intercepts):
                search_vector = atom.position - center
                print(search_vector)
                print()
                if min(search_vector) &gt; 0:
                    removal_indices.append(i)
        self.remove_atoms(*removal_indices)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="atompack.topology.Topology" href="../topology.html#atompack.topology.Topology">Topology</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="atompack.crystal.crystal.Crystal.lattice_vectors"><code class="name">var <span class="ident">lattice_vectors</span></code></dt>
<dd>
<div class="desc"><p>Returns the lattice vectors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lattice_vectors(self):
    &#34;&#34;&#34;Returns the lattice vectors.&#34;&#34;&#34;
    return self._lattice_vectors</code></pre>
</details>
</dd>
<dt id="atompack.crystal.crystal.Crystal.unit_cell"><code class="name">var <span class="ident">unit_cell</span></code></dt>
<dd>
<div class="desc"><p>Returns the unit cell.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unit_cell(self):
    &#34;&#34;&#34;Returns the unit cell.&#34;&#34;&#34;
    return self._unit_cell</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="atompack.crystal.crystal.Crystal.cut"><code class="name flex">
<span>def <span class="ident">cut</span></span>(<span>self, plane: <a title="atompack.crystal.spatial.Plane" href="spatial.html#atompack.crystal.spatial.Plane">Plane</a>) ‑> <a title="atompack.crystal.crystal.Crystal" href="#atompack.crystal.crystal.Crystal">Crystal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Cuts the crystal along a plane.
Mutates the crystal and returns a reference to itself to enable method chaining.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>plane</code></strong></dt>
<dd>Crystallographic plane to cut along.</dd>
</dl>
<h2 id="note">Note</h2>
<p>The transform is not applied until the <code>finish</code> method is called.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cut(self, plane: Plane) -&gt; &#39;Crystal&#39;:
    &#34;&#34;&#34;Cuts the crystal along a plane.
    Mutates the crystal and returns a reference to itself to enable method chaining.

    Args:
        plane: Crystallographic plane to cut along.

    Note:
        The transform is not applied until the `finish` method is called.
    &#34;&#34;&#34;
    self._cut_plane = plane
    return self</code></pre>
</details>
</dd>
<dt id="atompack.crystal.crystal.Crystal.finish"><code class="name flex">
<span>def <span class="ident">finish</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Applies all active transformations to the crystal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finish(self) -&gt; None:
    &#34;&#34;&#34;Applies all active transformations to the crystal.&#34;&#34;&#34;
    # call underlying implementations
    # TODO: determine best order
    self._project()
    self._general_transform()
    self._orient()
    self._supercell()
    self._cut()
    # reset attributes
    self._reset_attributes()</code></pre>
</details>
</dd>
<dt id="atompack.crystal.crystal.Crystal.general_transform"><code class="name flex">
<span>def <span class="ident">general_transform</span></span>(<span>self, transformation: numpy.ndarray) ‑> <a title="atompack.crystal.crystal.Crystal" href="#atompack.crystal.crystal.Crystal">Crystal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Applies a general transformation matrix to the crystal.
Mutates the crystal and returns a reference to itself to enable method chaining.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transformation</code></strong></dt>
<dd>Transformation matrix.</dd>
</dl>
<h2 id="note">Note</h2>
<p>The transform is not applied until the <code>finish</code> method is called.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def general_transform(self, transformation: np.ndarray) -&gt; &#39;Crystal&#39;:
    &#34;&#34;&#34;Applies a general transformation matrix to the crystal.
    Mutates the crystal and returns a reference to itself to enable method chaining.

    Args:
        transformation: Transformation matrix.

    Note:
        The transform is not applied until the `finish` method is called.
    &#34;&#34;&#34;
    raise NotImplementedError
    self._transformation_matrix = transformation
    return self</code></pre>
</details>
</dd>
<dt id="atompack.crystal.crystal.Crystal.orient"><code class="name flex">
<span>def <span class="ident">orient</span></span>(<span>self, orientation: <a title="atompack.crystal.spatial.Orientation" href="spatial.html#atompack.crystal.spatial.Orientation">Orientation</a>) ‑> <a title="atompack.crystal.crystal.Crystal" href="#atompack.crystal.crystal.Crystal">Crystal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Changes the crystal's orientation.
Mutates the crystal and returns a reference to itself to enable method chaining.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>orientation</code></strong></dt>
<dd>Crystallographic orientation.</dd>
</dl>
<h2 id="note">Note</h2>
<p>The transform is not applied until the <code>finish</code> method is called.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def orient(self, orientation: Orientation) -&gt; &#39;Crystal&#39;:
    &#34;&#34;&#34;Changes the crystal&#39;s orientation.
    Mutates the crystal and returns a reference to itself to enable method chaining.

    Args:
        orientation: Crystallographic orientation.

    Note:
        The transform is not applied until the `finish` method is called.
    &#34;&#34;&#34;
    raise NotImplementedError
    self._orientation = orientation
    return self</code></pre>
</details>
</dd>
<dt id="atompack.crystal.crystal.Crystal.project"><code class="name flex">
<span>def <span class="ident">project</span></span>(<span>self, plane: <a title="atompack.crystal.spatial.Plane" href="spatial.html#atompack.crystal.spatial.Plane">Plane</a>, orthogonalize: bool = False) ‑> <a title="atompack.crystal.crystal.Crystal" href="#atompack.crystal.crystal.Crystal">Crystal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Projects the crystal onto a plane.
Mutates the crystal and returns a reference to itself to enable method chaining.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>plane</code></strong></dt>
<dd>Projection plane.</dd>
<dt><strong><code>orthogonalize</code></strong></dt>
<dd>Determines whether or not the projection is represented as an orthogonal lattice.</dd>
</dl>
<h2 id="note">Note</h2>
<p>The transform is not applied until the <code>finish</code> method is called.
Setting <code>orthogonalize</code> to True may result in very large structures for acute projections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def project(self, plane: Plane, orthogonalize: bool = False) -&gt; &#39;Crystal&#39;:
    &#34;&#34;&#34;Projects the crystal onto a plane.
    Mutates the crystal and returns a reference to itself to enable method chaining.

    Args:
        plane: Projection plane.
        orthogonalize: Determines whether or not the projection is represented as an orthogonal lattice.

    Note:
        The transform is not applied until the `finish` method is called.
        Setting `orthogonalize` to True may result in very large structures for acute projections.
    &#34;&#34;&#34;
    raise NotImplementedError
    self._projection_plane = plane
    self._orthogonalize = orthogonalize
    return self</code></pre>
</details>
</dd>
<dt id="atompack.crystal.crystal.Crystal.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Undoes all transformations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self) -&gt; None:
    &#34;&#34;&#34;Undoes all transformations.&#34;&#34;&#34;
    super().__init__()
    self._reset_attributes()
    self._lattice_vectors = self.unit_cell.lattice_vectors.copy()
    for atom in self.unit_cell.atoms:
        self.insert_atoms(copy.deepcopy(atom))
    for bond in self.unit_cell.bonds:
        self.insert_bond(copy.deepcopy(bond))</code></pre>
</details>
</dd>
<dt id="atompack.crystal.crystal.Crystal.supercell"><code class="name flex">
<span>def <span class="ident">supercell</span></span>(<span>self, extent: Tuple[int, int, int]) ‑> <a title="atompack.crystal.crystal.Crystal" href="#atompack.crystal.crystal.Crystal">Crystal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a supercell by duplicating the crystal in 3 dimensions.
Mutates the crystal and returns a reference to itself to enable method chaining.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>extent</code></strong></dt>
<dd>Number of repeat units in each direction.</dd>
</dl>
<h2 id="note">Note</h2>
<p>The transform is not applied until the <code>finish</code> method is called.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def supercell(self, extent: Tuple[int, int, int]) -&gt; &#39;Crystal&#39;:
    &#34;&#34;&#34;Creates a supercell by duplicating the crystal in 3 dimensions.
    Mutates the crystal and returns a reference to itself to enable method chaining.

    Args:
        extent: Number of repeat units in each direction.

    Note:
        The transform is not applied until the `finish` method is called.
    &#34;&#34;&#34;
    self._extent = extent
    return self</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="atompack.topology.Topology" href="../topology.html#atompack.topology.Topology">Topology</a></b></code>:
<ul class="hlist">
<li><code><a title="atompack.topology.Topology.atoms" href="../topology.html#atompack.topology.Topology.atoms">atoms</a></code></li>
<li><code><a title="atompack.topology.Topology.bonds" href="../topology.html#atompack.topology.Topology.bonds">bonds</a></code></li>
<li><code><a title="atompack.topology.Topology.from_json" href="../topology.html#atompack.topology.Topology.from_json">from_json</a></code></li>
<li><code><a title="atompack.topology.Topology.insert_atoms" href="../topology.html#atompack.topology.Topology.insert_atoms">insert_atoms</a></code></li>
<li><code><a title="atompack.topology.Topology.insert_bond" href="../topology.html#atompack.topology.Topology.insert_bond">insert_bond</a></code></li>
<li><code><a title="atompack.topology.Topology.remove_atoms" href="../topology.html#atompack.topology.Topology.remove_atoms">remove_atoms</a></code></li>
<li><code><a title="atompack.topology.Topology.remove_bond" href="../topology.html#atompack.topology.Topology.remove_bond">remove_bond</a></code></li>
<li><code><a title="atompack.topology.Topology.select_atoms" href="../topology.html#atompack.topology.Topology.select_atoms">select_atoms</a></code></li>
<li><code><a title="atompack.topology.Topology.select_bond" href="../topology.html#atompack.topology.Topology.select_bond">select_bond</a></code></li>
<li><code><a title="atompack.topology.Topology.to_json" href="../topology.html#atompack.topology.Topology.to_json">to_json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="atompack.crystal.crystal.UnitCell"><code class="flex name class">
<span>class <span class="ident">UnitCell</span></span>
<span>(</span><span>basis: <a title="atompack.crystal.components.Basis" href="components.html#atompack.crystal.components.Basis">Basis</a>, lattice_parameters: <a title="atompack.crystal.components.LatticeParameters" href="components.html#atompack.crystal.components.LatticeParameters">LatticeParameters</a>, spacegroup: <a title="atompack.symmetry.Spacegroup" href="../symmetry.html#atompack.symmetry.Spacegroup">Spacegroup</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Minimal representation of a crystalline structure.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>basis</code></strong></dt>
<dd>Atomic basis.</dd>
<dt><strong><code>lattice_parameters</code></strong></dt>
<dd>Lattice parameters object.</dd>
<dt><strong><code>spacegroup</code></strong></dt>
<dd>Spacegroup object.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # primitive basis of iron
&gt;&gt;&gt; basis = Basis.primitive(&quot;Fe&quot;)
&gt;&gt;&gt; 
&gt;&gt;&gt; # cubic lattice parameters
&gt;&gt;&gt; lattparams = LatticeParameters.cubic(2.85)
&gt;&gt;&gt; 
&gt;&gt;&gt; # BCC spacegroup
&gt;&gt;&gt; spg = Spacegroup(&quot;I m -3 m&quot;)
&gt;&gt;&gt; 
&gt;&gt;&gt; # build the unit cell
&gt;&gt;&gt; unit_cell = UnitCell(basis, lattparams, spg)
&gt;&gt;&gt; assert len(unit_cell.atoms) == 2
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnitCell(Topology):
    &#34;&#34;&#34;Minimal representation of a crystalline structure.
    
    Args:
        basis: Atomic basis.
        lattice_parameters: Lattice parameters object.
        spacegroup: Spacegroup object.

    Example:
        &gt;&gt;&gt; # primitive basis of iron
        &gt;&gt;&gt; basis = Basis.primitive(&#34;Fe&#34;)
        &gt;&gt;&gt; 
        &gt;&gt;&gt; # cubic lattice parameters
        &gt;&gt;&gt; lattparams = LatticeParameters.cubic(2.85)
        &gt;&gt;&gt; 
        &gt;&gt;&gt; # BCC spacegroup
        &gt;&gt;&gt; spg = Spacegroup(&#34;I m -3 m&#34;)
        &gt;&gt;&gt; 
        &gt;&gt;&gt; # build the unit cell
        &gt;&gt;&gt; unit_cell = UnitCell(basis, lattparams, spg)
        &gt;&gt;&gt; assert len(unit_cell.atoms) == 2
    &#34;&#34;&#34;

    def __init__(
        self,
        basis: Basis,
        lattice_parameters: LatticeParameters,
        spacegroup: Spacegroup,
        _build: bool = True,
    ) -&gt; None:
        # initialize superclass
        super().__init__()
        # set attributes
        self._basis = basis
        self._lattice_parameters = lattice_parameters
        self._spacegroup = spacegroup
        # build the unit cell
        if _build:
            self._build()

    ######################
    #    Constructors    #
    ######################

    @classmethod
    def from_json(cls, s: str) -&gt; &#39;UnitCell&#39;:
        &#34;&#34;&#34;Initializes from a JSON string.&#34;&#34;&#34;
        topology = Topology.from_json(s)
        data = json.loads(s)
        basis = Basis.from_json(json.dumps(data[&#34;basis&#34;]))
        params = LatticeParameters.from_json(json.dumps(data[&#34;lattice_parameters&#34;]))
        spg = Spacegroup(int(data[&#34;spacegroup&#34;]))
        # initialize unit cell without placing atoms
        res = cls(basis, params, spg, _build=False)
        res._graph = topology._graph
        return res

    ####################
    #    Properties    #
    ####################

    @property
    def basis(self) -&gt; Basis:
        &#34;&#34;&#34;Returns the basis.&#34;&#34;&#34;
        return self._basis

    @property
    def lattice_parameters(self) -&gt; LatticeParameters:
        &#34;&#34;&#34;Returns the lattice parameters.&#34;&#34;&#34;
        return self._lattice_parameters

    @property
    def lattice_vectors(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns the lattice vectors.&#34;&#34;&#34;
        return np.sqrt(np.abs(self.lattice_parameters.metric_tensor))

    @property
    def spacegroup(self) -&gt; Spacegroup:
        &#34;&#34;&#34;Returns the spacegroup.&#34;&#34;&#34;
        return self._spacegroup

    ########################
    #    Public Methods    #
    ########################

    def to_json(self) -&gt; str:
        &#34;&#34;&#34;Returns the JSON serialized representation.&#34;&#34;&#34;
        topology_data = json.loads(super().to_json())
        return json.dumps({
            &#34;basis&#34;: json.loads(self.basis.to_json()),
            &#34;lattice_parameters&#34;: json.loads(self.lattice_parameters.to_json()),
            &#34;spacegroup&#34;: self.spacegroup.international_number,
            &#34;atoms&#34;: topology_data[&#34;atoms&#34;],
            &#34;bonds&#34;: topology_data[&#34;bonds&#34;],
        })

    #########################
    #    Private Methods    #
    #########################

    def _build(self) -&gt; None:
        for specie, site in self.basis.apply_spacegroup(self.spacegroup):
            position = site * np.linalg.norm(self.lattice_vectors, axis=0)
            self.insert_atoms(Atom(specie, position))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="atompack.topology.Topology" href="../topology.html#atompack.topology.Topology">Topology</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="atompack.crystal.crystal.UnitCell.basis"><code class="name">var <span class="ident">basis</span> : <a title="atompack.crystal.components.Basis" href="components.html#atompack.crystal.components.Basis">Basis</a></code></dt>
<dd>
<div class="desc"><p>Returns the basis.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def basis(self) -&gt; Basis:
    &#34;&#34;&#34;Returns the basis.&#34;&#34;&#34;
    return self._basis</code></pre>
</details>
</dd>
<dt id="atompack.crystal.crystal.UnitCell.lattice_parameters"><code class="name">var <span class="ident">lattice_parameters</span> : <a title="atompack.crystal.components.LatticeParameters" href="components.html#atompack.crystal.components.LatticeParameters">LatticeParameters</a></code></dt>
<dd>
<div class="desc"><p>Returns the lattice parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lattice_parameters(self) -&gt; LatticeParameters:
    &#34;&#34;&#34;Returns the lattice parameters.&#34;&#34;&#34;
    return self._lattice_parameters</code></pre>
</details>
</dd>
<dt id="atompack.crystal.crystal.UnitCell.lattice_vectors"><code class="name">var <span class="ident">lattice_vectors</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Returns the lattice vectors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lattice_vectors(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Returns the lattice vectors.&#34;&#34;&#34;
    return np.sqrt(np.abs(self.lattice_parameters.metric_tensor))</code></pre>
</details>
</dd>
<dt id="atompack.crystal.crystal.UnitCell.spacegroup"><code class="name">var <span class="ident">spacegroup</span> : <a title="atompack.symmetry.Spacegroup" href="../symmetry.html#atompack.symmetry.Spacegroup">Spacegroup</a></code></dt>
<dd>
<div class="desc"><p>Returns the spacegroup.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spacegroup(self) -&gt; Spacegroup:
    &#34;&#34;&#34;Returns the spacegroup.&#34;&#34;&#34;
    return self._spacegroup</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="atompack.topology.Topology" href="../topology.html#atompack.topology.Topology">Topology</a></b></code>:
<ul class="hlist">
<li><code><a title="atompack.topology.Topology.atoms" href="../topology.html#atompack.topology.Topology.atoms">atoms</a></code></li>
<li><code><a title="atompack.topology.Topology.bonds" href="../topology.html#atompack.topology.Topology.bonds">bonds</a></code></li>
<li><code><a title="atompack.topology.Topology.from_json" href="../topology.html#atompack.topology.Topology.from_json">from_json</a></code></li>
<li><code><a title="atompack.topology.Topology.insert_atoms" href="../topology.html#atompack.topology.Topology.insert_atoms">insert_atoms</a></code></li>
<li><code><a title="atompack.topology.Topology.insert_bond" href="../topology.html#atompack.topology.Topology.insert_bond">insert_bond</a></code></li>
<li><code><a title="atompack.topology.Topology.remove_atoms" href="../topology.html#atompack.topology.Topology.remove_atoms">remove_atoms</a></code></li>
<li><code><a title="atompack.topology.Topology.remove_bond" href="../topology.html#atompack.topology.Topology.remove_bond">remove_bond</a></code></li>
<li><code><a title="atompack.topology.Topology.select_atoms" href="../topology.html#atompack.topology.Topology.select_atoms">select_atoms</a></code></li>
<li><code><a title="atompack.topology.Topology.select_bond" href="../topology.html#atompack.topology.Topology.select_bond">select_bond</a></code></li>
<li><code><a title="atompack.topology.Topology.to_json" href="../topology.html#atompack.topology.Topology.to_json">to_json</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="atompack.crystal" href="index.html">atompack.crystal</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="atompack.crystal.crystal.Crystal" href="#atompack.crystal.crystal.Crystal">Crystal</a></code></h4>
<ul class="two-column">
<li><code><a title="atompack.crystal.crystal.Crystal.cut" href="#atompack.crystal.crystal.Crystal.cut">cut</a></code></li>
<li><code><a title="atompack.crystal.crystal.Crystal.finish" href="#atompack.crystal.crystal.Crystal.finish">finish</a></code></li>
<li><code><a title="atompack.crystal.crystal.Crystal.general_transform" href="#atompack.crystal.crystal.Crystal.general_transform">general_transform</a></code></li>
<li><code><a title="atompack.crystal.crystal.Crystal.lattice_vectors" href="#atompack.crystal.crystal.Crystal.lattice_vectors">lattice_vectors</a></code></li>
<li><code><a title="atompack.crystal.crystal.Crystal.orient" href="#atompack.crystal.crystal.Crystal.orient">orient</a></code></li>
<li><code><a title="atompack.crystal.crystal.Crystal.project" href="#atompack.crystal.crystal.Crystal.project">project</a></code></li>
<li><code><a title="atompack.crystal.crystal.Crystal.reset" href="#atompack.crystal.crystal.Crystal.reset">reset</a></code></li>
<li><code><a title="atompack.crystal.crystal.Crystal.supercell" href="#atompack.crystal.crystal.Crystal.supercell">supercell</a></code></li>
<li><code><a title="atompack.crystal.crystal.Crystal.unit_cell" href="#atompack.crystal.crystal.Crystal.unit_cell">unit_cell</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="atompack.crystal.crystal.UnitCell" href="#atompack.crystal.crystal.UnitCell">UnitCell</a></code></h4>
<ul class="">
<li><code><a title="atompack.crystal.crystal.UnitCell.basis" href="#atompack.crystal.crystal.UnitCell.basis">basis</a></code></li>
<li><code><a title="atompack.crystal.crystal.UnitCell.lattice_parameters" href="#atompack.crystal.crystal.UnitCell.lattice_parameters">lattice_parameters</a></code></li>
<li><code><a title="atompack.crystal.crystal.UnitCell.lattice_vectors" href="#atompack.crystal.crystal.UnitCell.lattice_vectors">lattice_vectors</a></code></li>
<li><code><a title="atompack.crystal.crystal.UnitCell.spacegroup" href="#atompack.crystal.crystal.UnitCell.spacegroup">spacegroup</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>