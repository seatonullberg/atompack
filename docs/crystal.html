<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>atompack.crystal API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>atompack.crystal</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from collections.abc import MutableSequence
from typing import List, Tuple, Union

import numpy as np
from scipy.spatial.transform import Rotation

from atompack.atom import Atom
from atompack.constants import DEG90, DEG120
from atompack.spacegroup import Spacegroup
from atompack.topology import Topology


class Basis(MutableSequence):
    &#34;&#34;&#34;Crystalline basis.
    
    Example:
        &gt;&gt;&gt; from atompack.crystal import Basis
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt;
        &gt;&gt;&gt; # primitive basis of iron atoms
        &gt;&gt;&gt; basis = Basis.primitive(&#34;Fe&#34;)
        &gt;&gt;&gt; assert len(basis) == 1
        &gt;&gt;&gt;
        &gt;&gt;&gt; site, specie = basis[0]
        &gt;&gt;&gt; assert specie == &#34;Fe&#34;
        &gt;&gt;&gt; assert np.array_equal(site, np.zeros(3))
    &#34;&#34;&#34;

    def __init__(self, basis: List[Tuple[np.ndarray, str]]) -&gt; None:
        for site, _ in basis:
            if max(site) &gt; 1 or min(site) &lt; -1:
                raise ValueError(&#34;basis sites must be represented in fractional coordinates&#34;)
        self._basis = basis

    ########################################
    #    MutableSequence Implementation    #
    ########################################

    def __getitem__(self, index: int) -&gt; Tuple[np.ndarray, str]:
        return self._basis[index]

    def __setitem__(self, index: int, value: Tuple[np.ndarray, str]) -&gt; None:
        self._basis[index] = value

    def __delitem__(self, index: int) -&gt; None:
        del self._basis[index]

    def __len__(self) -&gt; int:
        return len(self._basis)

    def insert(self, index: int, value: Tuple[np.ndarray, str]) -&gt; None:
        self._basis.insert(index, value)

    ######################
    #    Constructors    #
    ######################

    @classmethod
    def primitive(cls, specie: str) -&gt; &#39;Basis&#39;:
        &#34;&#34;&#34;Returns a primitive basis.&#34;&#34;&#34;
        return cls([(np.zeros(3), specie)])
    
    ########################
    #    Public Methods    #
    ########################

    def apply_spacegroup(self, spacegroup: Spacegroup) -&gt; List[Tuple[np.ndarray, str]]:
        &#34;&#34;&#34;Returns a list of site/specie pairs generated by applying a spacegroup&#39;s
        symmetry operations to the atomic basis.&#34;&#34;&#34;
        # search tolerance
        tolerance = 1E-6

        # skip process if no sites exist
        if len(self) == 0:
            return []

        res = [self._basis[0]]
        # iterate over basis
        for site, specie in self._basis:
            # iterate through the spacegroup&#39;s general position expressions
            for genpos in spacegroup.genpos:
                # convert string expressions to arrays
                genpos = &#34;[{}]&#34;.format(genpos)
                x, y, z = site[0], site[1], site[2]
                new_site = np.array(eval(genpos))
                # wrap all values between 0-1
                for i in range(len(new_site)):
                    if new_site[i] &lt; 0:
                        new_site[i] += 1
                # check if equivalent site exists
                is_occupied = False
                for _site, _ in res:
                    if np.linalg.norm(new_site - _site) &lt; tolerance:
                        is_occupied = True
                # store unique sites
                if not is_occupied:
                    res.append((new_site, specie))
        return res


class LatticeParameters(object):
    &#34;&#34;&#34;Edge lengths and angles which define a lattice.
    
    Args:
        a: Length of the x lattice vector.
        b: Length of the y lattice vector.
        c: Length of the z lattice vector.
        alpha: Angle between the y and z directions (radians).
        beta: Angle between the x and z directions (radians).
        gamma: Angle between the x and y directions (radians).

    Example:
        &gt;&gt;&gt; from atompack.crystal import LatticeParameters
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt;
        &gt;&gt;&gt; # cubic lattice parameters
        &gt;&gt;&gt; params = LatticeParameters.cubic(10)
        &gt;&gt;&gt; assert params.a == params.b == params.c == 10
        &gt;&gt;&gt; assert params.alpha == params.beta == params.gamma == np.pi / 2
    &#34;&#34;&#34;

    def __init__(self, a: float, b: float, c: float, alpha: float, beta: float, gamma: float) -&gt; None:
        self.a = a
        self.b = b
        self.c = c
        self.alpha = alpha
        self.beta = beta
        self.gamma = gamma

    ######################
    #    Constructors    #
    ######################

    @classmethod
    def triclinic(cls, a, b, c, alpha, beta, gamma) -&gt; &#39;LatticeParameters&#39;:
        &#34;&#34;&#34;Initialize with triclinic constraints.&#34;&#34;&#34;
        return cls(a, b, c, alpha, beta, gamma)

    @classmethod
    def monoclinic(cls, a, b, c, beta) -&gt; &#39;LatticeParameters&#39;:
        &#34;&#34;&#34;Initialize with monoclinic constraints.&#34;&#34;&#34;
        return cls(a, b, c, DEG90, beta, DEG90)

    @classmethod
    def orthorhombic(cls, a, b, c) -&gt; &#39;LatticeParameters&#39;:
        &#34;&#34;&#34;Initialize with orthorhombic constraints.&#34;&#34;&#34;
        return cls(a, b, c, DEG90, DEG90, DEG90)

    @classmethod
    def tetragonal(cls, a, c) -&gt; &#39;LatticeParameters&#39;:
        &#34;&#34;&#34;Initialize with tetragonal constraints.&#34;&#34;&#34;
        return cls(a, a, c, DEG90, DEG90, DEG90)

    @classmethod
    def trigonal(cls, a, c) -&gt; &#39;LatticeParameters&#39;:
        &#34;&#34;&#34;Initialize with trigonal constraints.&#34;&#34;&#34;
        return cls(a, a, c, DEG90, DEG90, DEG120)

    @classmethod
    def rhombohedral(cls, a, alpha) -&gt; &#39;LatticeParameters&#39;:
        &#34;&#34;&#34;Initialize with rhombohedral constraints.&#34;&#34;&#34;
        return cls(a, a, a, alpha, alpha, alpha)

    @classmethod
    def hexagonal(cls, a, c) -&gt; &#39;LatticeParameters&#39;:
        &#34;&#34;&#34;Initialize with hexagonal constraints.&#34;&#34;&#34;
        return cls(a, a, c, DEG90, DEG90, DEG120)

    @classmethod
    def cubic(cls, a) -&gt; &#39;LatticeParameters&#39;:
        &#34;&#34;&#34;Initialize with cubic constraints.&#34;&#34;&#34;
        return cls(a, a, a, DEG90, DEG90, DEG90)

    ####################
    #    Properties    #
    ####################

    @property
    def metric_tensor(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns the metric tensor defined by the lattice parameters.&#34;&#34;&#34;
        return np.array([[self.a * self.a, self.a * self.b * np.cos(self.gamma), self.a * self.c * np.cos(self.beta)],
                         [self.a * self.b * np.cos(self.gamma), self.b * self.b, self.b * self.c * np.cos(self.alpha)],
                         [self.a * self.c * np.cos(self.beta), self.b * self.c * np.cos(self.alpha), self.c * self.c]])


class Orientation(Rotation):
    &#34;&#34;&#34;Representation of a crystallographic orientation.
    This class inherits from `scipy.spatial.transform.Rotation`.
    &#34;&#34;&#34;

    ######################
    #    Constructors    #
    ######################

    @classmethod
    def from_miller_indices(cls, hkl: Tuple[int, int, int], uvw: Tuple[int, int, int]) -&gt; &#39;Orientation&#39;:
        &#34;&#34;&#34;Initialize from Miller Indices.
        
        Args:
            hkl: Indices of the plane.
            uvw: Indices of the direction.
        &#34;&#34;&#34;
        pass

    ########################
    #    Public Methods    #
    ########################

    def as_miller_indices(self) -&gt; Tuple[Tuple[int, int, int], Tuple[int, int, int]]:
        &#34;&#34;&#34;Represent as Miller Indices.&#34;&#34;&#34;
        pass


class Plane(object):

    ######################
    #    Constructors    #
    ######################

    @classmethod
    def from_miller_indices(cls, hkl: Tuple[int, int, int]) -&gt; &#39;Plane&#39;:
        &#34;&#34;&#34;Initialize from Miller Indices.&#34;&#34;&#34;
        pass


class UnitCell(Topology):
    &#34;&#34;&#34;Minimal representation of a crystalline structure.

    Note:
        End users should not construct unit cell objects directly.
    
    Args:
        basis: Asymmetric site occupancy.
        lattice_parameters: Lattice parameters object.
        spacegroup: Spacegroup object.
    &#34;&#34;&#34;

    def __init__(self, basis: Basis, lattice_parameters: LatticeParameters, spacegroup: Spacegroup) -&gt; None:
        super().__init__()
        self._basis = basis
        self._lattice_parameters = lattice_parameters
        self._spacegroup = spacegroup
        self._build()

    ####################
    #    Properties    #
    ####################

    @property
    def basis(self) -&gt; Basis:
        &#34;&#34;&#34;Returns the basis.&#34;&#34;&#34;
        return self._basis

    @property
    def lattice_parameters(self) -&gt; LatticeParameters:
        &#34;&#34;&#34;Returns the lattice parameters.&#34;&#34;&#34;
        return self._lattice_parameters
    
    @property
    def lattice_vectors(self) -&gt; np.ndarray:
        return np.sqrt(np.abs(self.lattice_parameters.metric_tensor))

    @property
    def spacegroup(self) -&gt; Spacegroup:
        &#34;&#34;&#34;Returns the spacegroup.&#34;&#34;&#34;
        return self._spacegroup

    #########################
    #    Private Methods    #
    #########################

    def _build(self) -&gt; None:
        for site, specie in self.basis.apply_spacegroup(self.spacegroup):
            position = site * np.linalg.norm(self.lattice_vectors, axis=0)
            self.atoms.append(Atom(position, specie))


class Crystal(Topology):
    &#34;&#34;&#34;Atomic structure with long range order.
    
    Args:
        basis: Atomic basis set.
        lattice_parameters: Lattice parameters object.
        spacegroup: Spacegroup object.
    &#34;&#34;&#34;

    def __init__(self, basis: List[Tuple[str, np.ndarray]], lattice_parameters: LatticeParameters,
                 spacegroup: Spacegroup) -&gt; None:
        # initialize attributes
        self._cut_plane: Optional[Plane] = None
        self._extent: Optional[Tuple[int, int, int]] = None
        self._orientation: Optional[Orientation] = None
        self._orthogonalize: Optional[bool] = None
        self._projection_plane: Optional[Plane] = None
        self._transformation_matrix: Optional[np.ndarray] = None
        # initialize superclass
        super().__init__()
        # copy attributes from unit cell
        self._unit_cell = UnitCell(basis, lattice_parameters, spacegroup)
        self._lattice_vectors = self._unit_cell._lattice_parameters.metric_tensor.copy()
        self.atoms = self._unit_cell.atoms.copy()

    ####################
    #    Properties    #
    ####################

    @property
    def lattice_vectors(self):
        &#34;&#34;&#34;Returns the lattice vectors.&#34;&#34;&#34;
        return self._lattice_vectors

    @property
    def unit_cell(self):
        &#34;&#34;&#34;Returns the unit cell.&#34;&#34;&#34;
        return self._unit_cell

    ########################
    #    Public Methods    #
    ########################

    def general_transform(self, transformation: np.ndarray) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Applies a general transformation matrix to the crystal.
        Mutates the crystal and returns a reference to itself to enable method chaining.

        Args:
            transformation: Transformation matrix.

        Note:
            This method is idempotent.
            The transform is not applied until the `finish` method is called.
        &#34;&#34;&#34;
        self._transformation_matrix = transformation
        return self

    def supercell(self, extent: Tuple[int, int, int]) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Creates a supercell by duplicating the crystal&#39;s unit cell in 3 dimensions.
        Mutates the crystal and returns a reference to itself to enable method chaining.

        Args:
            extent: Number of repeat units in each direction.

        Note:
            This method is idempotent.
            The transform is not applied until the `finish` method is called.
        &#34;&#34;&#34;
        self._extent = extent
        return self

    def orient(self, orientation: Orientation) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Change the crystal&#39;s orientation.
        Mutates the crystal and returns a reference to itself to enable method chaining.

        Args:
            orientation: Crystallographic orientation.

        Note:
            This method is idempotent.
            The transform is not applied until the `finish` method is called.
        &#34;&#34;&#34;
        self._orientation = orientation
        return self

    def project(self, plane: Plane, orthogonalize: bool = False) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Project the crystal onto a plane.
        Mutates the crystal and returns a reference to itself to enable method chaining.

        Args:
            plane: Projection plane.
            orthogonalize: Determines whether or not the projection is represented as an orthogonal lattice.

        Note:
            This method is idempotent.
            The transform is not applied until the `finish` method is called.
            Setting `orthogonalize` to True may result in very large structures for acute projections.
        &#34;&#34;&#34;
        self._projection_plane = plane
        self._orthogonalize = orthogonalize
        return self

    def cut(self, plane: Plane) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Cut the crystal along a plane.
        Mutates the crystal and returns a reference to itself to enable method chaining.

        Args:
            plane: Plane to cut along.

        Note:
            This method is idempotent.
            The transform is not applied until the `finish` method is called.
        &#34;&#34;&#34;
        self._cut_plane = plane
        return self

    def finish(self) -&gt; None:
        &#34;&#34;&#34;Applies all active transforms to the crystal.&#34;&#34;&#34;
        # TODO: call underlying implementations

        # reset attributes
        self._cut_plane = None
        self._extent = None
        self._orientation = None
        self._orthogonalize = None
        self._projection_plane = None
        self._transformation_matrix = None

    #########################
    #    Private Methods    #
    #########################

    def _general_transform(self) -&gt; None:
        pass

    def _supercell(self) -&gt; None:
        pass

    def _orient(self) -&gt; None:
        pass

    def _project(self) -&gt; None:
        pass

    def _cut(self) -&gt; None:
        pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="atompack.crystal.Basis"><code class="flex name class">
<span>class <span class="ident">Basis</span></span>
<span>(</span><span>basis: List[Tuple[numpy.ndarray, str]])</span>
</code></dt>
<dd>
<div class="desc"><p>Crystalline basis.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from atompack.crystal import Basis
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt;
&gt;&gt;&gt; # primitive basis of iron atoms
&gt;&gt;&gt; basis = Basis.primitive(&quot;Fe&quot;)
&gt;&gt;&gt; assert len(basis) == 1
&gt;&gt;&gt;
&gt;&gt;&gt; site, specie = basis[0]
&gt;&gt;&gt; assert specie == &quot;Fe&quot;
&gt;&gt;&gt; assert np.array_equal(site, np.zeros(3))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Basis(MutableSequence):
    &#34;&#34;&#34;Crystalline basis.
    
    Example:
        &gt;&gt;&gt; from atompack.crystal import Basis
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt;
        &gt;&gt;&gt; # primitive basis of iron atoms
        &gt;&gt;&gt; basis = Basis.primitive(&#34;Fe&#34;)
        &gt;&gt;&gt; assert len(basis) == 1
        &gt;&gt;&gt;
        &gt;&gt;&gt; site, specie = basis[0]
        &gt;&gt;&gt; assert specie == &#34;Fe&#34;
        &gt;&gt;&gt; assert np.array_equal(site, np.zeros(3))
    &#34;&#34;&#34;

    def __init__(self, basis: List[Tuple[np.ndarray, str]]) -&gt; None:
        for site, _ in basis:
            if max(site) &gt; 1 or min(site) &lt; -1:
                raise ValueError(&#34;basis sites must be represented in fractional coordinates&#34;)
        self._basis = basis

    ########################################
    #    MutableSequence Implementation    #
    ########################################

    def __getitem__(self, index: int) -&gt; Tuple[np.ndarray, str]:
        return self._basis[index]

    def __setitem__(self, index: int, value: Tuple[np.ndarray, str]) -&gt; None:
        self._basis[index] = value

    def __delitem__(self, index: int) -&gt; None:
        del self._basis[index]

    def __len__(self) -&gt; int:
        return len(self._basis)

    def insert(self, index: int, value: Tuple[np.ndarray, str]) -&gt; None:
        self._basis.insert(index, value)

    ######################
    #    Constructors    #
    ######################

    @classmethod
    def primitive(cls, specie: str) -&gt; &#39;Basis&#39;:
        &#34;&#34;&#34;Returns a primitive basis.&#34;&#34;&#34;
        return cls([(np.zeros(3), specie)])
    
    ########################
    #    Public Methods    #
    ########################

    def apply_spacegroup(self, spacegroup: Spacegroup) -&gt; List[Tuple[np.ndarray, str]]:
        &#34;&#34;&#34;Returns a list of site/specie pairs generated by applying a spacegroup&#39;s
        symmetry operations to the atomic basis.&#34;&#34;&#34;
        # search tolerance
        tolerance = 1E-6

        # skip process if no sites exist
        if len(self) == 0:
            return []

        res = [self._basis[0]]
        # iterate over basis
        for site, specie in self._basis:
            # iterate through the spacegroup&#39;s general position expressions
            for genpos in spacegroup.genpos:
                # convert string expressions to arrays
                genpos = &#34;[{}]&#34;.format(genpos)
                x, y, z = site[0], site[1], site[2]
                new_site = np.array(eval(genpos))
                # wrap all values between 0-1
                for i in range(len(new_site)):
                    if new_site[i] &lt; 0:
                        new_site[i] += 1
                # check if equivalent site exists
                is_occupied = False
                for _site, _ in res:
                    if np.linalg.norm(new_site - _site) &lt; tolerance:
                        is_occupied = True
                # store unique sites
                if not is_occupied:
                    res.append((new_site, specie))
        return res</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>collections.abc.MutableSequence</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="atompack.crystal.Basis.primitive"><code class="name flex">
<span>def <span class="ident">primitive</span></span>(<span>specie: str) ‑> <a title="atompack.crystal.Basis" href="#atompack.crystal.Basis">Basis</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a primitive basis.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def primitive(cls, specie: str) -&gt; &#39;Basis&#39;:
    &#34;&#34;&#34;Returns a primitive basis.&#34;&#34;&#34;
    return cls([(np.zeros(3), specie)])</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="atompack.crystal.Basis.apply_spacegroup"><code class="name flex">
<span>def <span class="ident">apply_spacegroup</span></span>(<span>self, spacegroup: <a title="atompack.spacegroup.Spacegroup" href="spacegroup.html#atompack.spacegroup.Spacegroup">Spacegroup</a>) ‑> List[Tuple[numpy.ndarray, str]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of site/specie pairs generated by applying a spacegroup's
symmetry operations to the atomic basis.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_spacegroup(self, spacegroup: Spacegroup) -&gt; List[Tuple[np.ndarray, str]]:
    &#34;&#34;&#34;Returns a list of site/specie pairs generated by applying a spacegroup&#39;s
    symmetry operations to the atomic basis.&#34;&#34;&#34;
    # search tolerance
    tolerance = 1E-6

    # skip process if no sites exist
    if len(self) == 0:
        return []

    res = [self._basis[0]]
    # iterate over basis
    for site, specie in self._basis:
        # iterate through the spacegroup&#39;s general position expressions
        for genpos in spacegroup.genpos:
            # convert string expressions to arrays
            genpos = &#34;[{}]&#34;.format(genpos)
            x, y, z = site[0], site[1], site[2]
            new_site = np.array(eval(genpos))
            # wrap all values between 0-1
            for i in range(len(new_site)):
                if new_site[i] &lt; 0:
                    new_site[i] += 1
            # check if equivalent site exists
            is_occupied = False
            for _site, _ in res:
                if np.linalg.norm(new_site - _site) &lt; tolerance:
                    is_occupied = True
            # store unique sites
            if not is_occupied:
                res.append((new_site, specie))
    return res</code></pre>
</details>
</dd>
<dt id="atompack.crystal.Basis.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, index: int, value: Tuple[numpy.ndarray, str]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>S.insert(index, value) &ndash; insert value before index</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert(self, index: int, value: Tuple[np.ndarray, str]) -&gt; None:
    self._basis.insert(index, value)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="atompack.crystal.Crystal"><code class="flex name class">
<span>class <span class="ident">Crystal</span></span>
<span>(</span><span>basis: List[Tuple[str, numpy.ndarray]], lattice_parameters: <a title="atompack.crystal.LatticeParameters" href="#atompack.crystal.LatticeParameters">LatticeParameters</a>, spacegroup: <a title="atompack.spacegroup.Spacegroup" href="spacegroup.html#atompack.spacegroup.Spacegroup">Spacegroup</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Atomic structure with long range order.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>basis</code></strong></dt>
<dd>Atomic basis set.</dd>
<dt><strong><code>lattice_parameters</code></strong></dt>
<dd>Lattice parameters object.</dd>
<dt><strong><code>spacegroup</code></strong></dt>
<dd>Spacegroup object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Crystal(Topology):
    &#34;&#34;&#34;Atomic structure with long range order.
    
    Args:
        basis: Atomic basis set.
        lattice_parameters: Lattice parameters object.
        spacegroup: Spacegroup object.
    &#34;&#34;&#34;

    def __init__(self, basis: List[Tuple[str, np.ndarray]], lattice_parameters: LatticeParameters,
                 spacegroup: Spacegroup) -&gt; None:
        # initialize attributes
        self._cut_plane: Optional[Plane] = None
        self._extent: Optional[Tuple[int, int, int]] = None
        self._orientation: Optional[Orientation] = None
        self._orthogonalize: Optional[bool] = None
        self._projection_plane: Optional[Plane] = None
        self._transformation_matrix: Optional[np.ndarray] = None
        # initialize superclass
        super().__init__()
        # copy attributes from unit cell
        self._unit_cell = UnitCell(basis, lattice_parameters, spacegroup)
        self._lattice_vectors = self._unit_cell._lattice_parameters.metric_tensor.copy()
        self.atoms = self._unit_cell.atoms.copy()

    ####################
    #    Properties    #
    ####################

    @property
    def lattice_vectors(self):
        &#34;&#34;&#34;Returns the lattice vectors.&#34;&#34;&#34;
        return self._lattice_vectors

    @property
    def unit_cell(self):
        &#34;&#34;&#34;Returns the unit cell.&#34;&#34;&#34;
        return self._unit_cell

    ########################
    #    Public Methods    #
    ########################

    def general_transform(self, transformation: np.ndarray) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Applies a general transformation matrix to the crystal.
        Mutates the crystal and returns a reference to itself to enable method chaining.

        Args:
            transformation: Transformation matrix.

        Note:
            This method is idempotent.
            The transform is not applied until the `finish` method is called.
        &#34;&#34;&#34;
        self._transformation_matrix = transformation
        return self

    def supercell(self, extent: Tuple[int, int, int]) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Creates a supercell by duplicating the crystal&#39;s unit cell in 3 dimensions.
        Mutates the crystal and returns a reference to itself to enable method chaining.

        Args:
            extent: Number of repeat units in each direction.

        Note:
            This method is idempotent.
            The transform is not applied until the `finish` method is called.
        &#34;&#34;&#34;
        self._extent = extent
        return self

    def orient(self, orientation: Orientation) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Change the crystal&#39;s orientation.
        Mutates the crystal and returns a reference to itself to enable method chaining.

        Args:
            orientation: Crystallographic orientation.

        Note:
            This method is idempotent.
            The transform is not applied until the `finish` method is called.
        &#34;&#34;&#34;
        self._orientation = orientation
        return self

    def project(self, plane: Plane, orthogonalize: bool = False) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Project the crystal onto a plane.
        Mutates the crystal and returns a reference to itself to enable method chaining.

        Args:
            plane: Projection plane.
            orthogonalize: Determines whether or not the projection is represented as an orthogonal lattice.

        Note:
            This method is idempotent.
            The transform is not applied until the `finish` method is called.
            Setting `orthogonalize` to True may result in very large structures for acute projections.
        &#34;&#34;&#34;
        self._projection_plane = plane
        self._orthogonalize = orthogonalize
        return self

    def cut(self, plane: Plane) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Cut the crystal along a plane.
        Mutates the crystal and returns a reference to itself to enable method chaining.

        Args:
            plane: Plane to cut along.

        Note:
            This method is idempotent.
            The transform is not applied until the `finish` method is called.
        &#34;&#34;&#34;
        self._cut_plane = plane
        return self

    def finish(self) -&gt; None:
        &#34;&#34;&#34;Applies all active transforms to the crystal.&#34;&#34;&#34;
        # TODO: call underlying implementations

        # reset attributes
        self._cut_plane = None
        self._extent = None
        self._orientation = None
        self._orthogonalize = None
        self._projection_plane = None
        self._transformation_matrix = None

    #########################
    #    Private Methods    #
    #########################

    def _general_transform(self) -&gt; None:
        pass

    def _supercell(self) -&gt; None:
        pass

    def _orient(self) -&gt; None:
        pass

    def _project(self) -&gt; None:
        pass

    def _cut(self) -&gt; None:
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="atompack.topology.Topology" href="topology.html#atompack.topology.Topology">Topology</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="atompack.crystal.Crystal.lattice_vectors"><code class="name">var <span class="ident">lattice_vectors</span></code></dt>
<dd>
<div class="desc"><p>Returns the lattice vectors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lattice_vectors(self):
    &#34;&#34;&#34;Returns the lattice vectors.&#34;&#34;&#34;
    return self._lattice_vectors</code></pre>
</details>
</dd>
<dt id="atompack.crystal.Crystal.unit_cell"><code class="name">var <span class="ident">unit_cell</span></code></dt>
<dd>
<div class="desc"><p>Returns the unit cell.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unit_cell(self):
    &#34;&#34;&#34;Returns the unit cell.&#34;&#34;&#34;
    return self._unit_cell</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="atompack.crystal.Crystal.cut"><code class="name flex">
<span>def <span class="ident">cut</span></span>(<span>self, plane: <a title="atompack.crystal.Plane" href="#atompack.crystal.Plane">Plane</a>) ‑> <a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Cut the crystal along a plane.
Mutates the crystal and returns a reference to itself to enable method chaining.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>plane</code></strong></dt>
<dd>Plane to cut along.</dd>
</dl>
<h2 id="note">Note</h2>
<p>This method is idempotent.
The transform is not applied until the <code>finish</code> method is called.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cut(self, plane: Plane) -&gt; &#39;Crystal&#39;:
    &#34;&#34;&#34;Cut the crystal along a plane.
    Mutates the crystal and returns a reference to itself to enable method chaining.

    Args:
        plane: Plane to cut along.

    Note:
        This method is idempotent.
        The transform is not applied until the `finish` method is called.
    &#34;&#34;&#34;
    self._cut_plane = plane
    return self</code></pre>
</details>
</dd>
<dt id="atompack.crystal.Crystal.finish"><code class="name flex">
<span>def <span class="ident">finish</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Applies all active transforms to the crystal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finish(self) -&gt; None:
    &#34;&#34;&#34;Applies all active transforms to the crystal.&#34;&#34;&#34;
    # TODO: call underlying implementations

    # reset attributes
    self._cut_plane = None
    self._extent = None
    self._orientation = None
    self._orthogonalize = None
    self._projection_plane = None
    self._transformation_matrix = None</code></pre>
</details>
</dd>
<dt id="atompack.crystal.Crystal.general_transform"><code class="name flex">
<span>def <span class="ident">general_transform</span></span>(<span>self, transformation: numpy.ndarray) ‑> <a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Applies a general transformation matrix to the crystal.
Mutates the crystal and returns a reference to itself to enable method chaining.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transformation</code></strong></dt>
<dd>Transformation matrix.</dd>
</dl>
<h2 id="note">Note</h2>
<p>This method is idempotent.
The transform is not applied until the <code>finish</code> method is called.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def general_transform(self, transformation: np.ndarray) -&gt; &#39;Crystal&#39;:
    &#34;&#34;&#34;Applies a general transformation matrix to the crystal.
    Mutates the crystal and returns a reference to itself to enable method chaining.

    Args:
        transformation: Transformation matrix.

    Note:
        This method is idempotent.
        The transform is not applied until the `finish` method is called.
    &#34;&#34;&#34;
    self._transformation_matrix = transformation
    return self</code></pre>
</details>
</dd>
<dt id="atompack.crystal.Crystal.orient"><code class="name flex">
<span>def <span class="ident">orient</span></span>(<span>self, orientation: <a title="atompack.crystal.Orientation" href="#atompack.crystal.Orientation">Orientation</a>) ‑> <a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Change the crystal's orientation.
Mutates the crystal and returns a reference to itself to enable method chaining.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>orientation</code></strong></dt>
<dd>Crystallographic orientation.</dd>
</dl>
<h2 id="note">Note</h2>
<p>This method is idempotent.
The transform is not applied until the <code>finish</code> method is called.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def orient(self, orientation: Orientation) -&gt; &#39;Crystal&#39;:
    &#34;&#34;&#34;Change the crystal&#39;s orientation.
    Mutates the crystal and returns a reference to itself to enable method chaining.

    Args:
        orientation: Crystallographic orientation.

    Note:
        This method is idempotent.
        The transform is not applied until the `finish` method is called.
    &#34;&#34;&#34;
    self._orientation = orientation
    return self</code></pre>
</details>
</dd>
<dt id="atompack.crystal.Crystal.project"><code class="name flex">
<span>def <span class="ident">project</span></span>(<span>self, plane: <a title="atompack.crystal.Plane" href="#atompack.crystal.Plane">Plane</a>, orthogonalize: bool = False) ‑> <a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Project the crystal onto a plane.
Mutates the crystal and returns a reference to itself to enable method chaining.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>plane</code></strong></dt>
<dd>Projection plane.</dd>
<dt><strong><code>orthogonalize</code></strong></dt>
<dd>Determines whether or not the projection is represented as an orthogonal lattice.</dd>
</dl>
<h2 id="note">Note</h2>
<p>This method is idempotent.
The transform is not applied until the <code>finish</code> method is called.
Setting <code>orthogonalize</code> to True may result in very large structures for acute projections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def project(self, plane: Plane, orthogonalize: bool = False) -&gt; &#39;Crystal&#39;:
    &#34;&#34;&#34;Project the crystal onto a plane.
    Mutates the crystal and returns a reference to itself to enable method chaining.

    Args:
        plane: Projection plane.
        orthogonalize: Determines whether or not the projection is represented as an orthogonal lattice.

    Note:
        This method is idempotent.
        The transform is not applied until the `finish` method is called.
        Setting `orthogonalize` to True may result in very large structures for acute projections.
    &#34;&#34;&#34;
    self._projection_plane = plane
    self._orthogonalize = orthogonalize
    return self</code></pre>
</details>
</dd>
<dt id="atompack.crystal.Crystal.supercell"><code class="name flex">
<span>def <span class="ident">supercell</span></span>(<span>self, extent: Tuple[int, int, int]) ‑> <a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a supercell by duplicating the crystal's unit cell in 3 dimensions.
Mutates the crystal and returns a reference to itself to enable method chaining.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>extent</code></strong></dt>
<dd>Number of repeat units in each direction.</dd>
</dl>
<h2 id="note">Note</h2>
<p>This method is idempotent.
The transform is not applied until the <code>finish</code> method is called.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def supercell(self, extent: Tuple[int, int, int]) -&gt; &#39;Crystal&#39;:
    &#34;&#34;&#34;Creates a supercell by duplicating the crystal&#39;s unit cell in 3 dimensions.
    Mutates the crystal and returns a reference to itself to enable method chaining.

    Args:
        extent: Number of repeat units in each direction.

    Note:
        This method is idempotent.
        The transform is not applied until the `finish` method is called.
    &#34;&#34;&#34;
    self._extent = extent
    return self</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="atompack.topology.Topology" href="topology.html#atompack.topology.Topology">Topology</a></b></code>:
<ul class="hlist">
<li><code><a title="atompack.topology.Topology.atoms" href="topology.html#atompack.topology.Topology.atoms">atoms</a></code></li>
<li><code><a title="atompack.topology.Topology.bonds" href="topology.html#atompack.topology.Topology.bonds">bonds</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="atompack.crystal.LatticeParameters"><code class="flex name class">
<span>class <span class="ident">LatticeParameters</span></span>
<span>(</span><span>a: float, b: float, c: float, alpha: float, beta: float, gamma: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Edge lengths and angles which define a lattice.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>a</code></strong></dt>
<dd>Length of the x lattice vector.</dd>
<dt><strong><code>b</code></strong></dt>
<dd>Length of the y lattice vector.</dd>
<dt><strong><code>c</code></strong></dt>
<dd>Length of the z lattice vector.</dd>
<dt><strong><code>alpha</code></strong></dt>
<dd>Angle between the y and z directions (radians).</dd>
<dt><strong><code>beta</code></strong></dt>
<dd>Angle between the x and z directions (radians).</dd>
<dt><strong><code>gamma</code></strong></dt>
<dd>Angle between the x and y directions (radians).</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from atompack.crystal import LatticeParameters
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt;
&gt;&gt;&gt; # cubic lattice parameters
&gt;&gt;&gt; params = LatticeParameters.cubic(10)
&gt;&gt;&gt; assert params.a == params.b == params.c == 10
&gt;&gt;&gt; assert params.alpha == params.beta == params.gamma == np.pi / 2
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LatticeParameters(object):
    &#34;&#34;&#34;Edge lengths and angles which define a lattice.
    
    Args:
        a: Length of the x lattice vector.
        b: Length of the y lattice vector.
        c: Length of the z lattice vector.
        alpha: Angle between the y and z directions (radians).
        beta: Angle between the x and z directions (radians).
        gamma: Angle between the x and y directions (radians).

    Example:
        &gt;&gt;&gt; from atompack.crystal import LatticeParameters
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt;
        &gt;&gt;&gt; # cubic lattice parameters
        &gt;&gt;&gt; params = LatticeParameters.cubic(10)
        &gt;&gt;&gt; assert params.a == params.b == params.c == 10
        &gt;&gt;&gt; assert params.alpha == params.beta == params.gamma == np.pi / 2
    &#34;&#34;&#34;

    def __init__(self, a: float, b: float, c: float, alpha: float, beta: float, gamma: float) -&gt; None:
        self.a = a
        self.b = b
        self.c = c
        self.alpha = alpha
        self.beta = beta
        self.gamma = gamma

    ######################
    #    Constructors    #
    ######################

    @classmethod
    def triclinic(cls, a, b, c, alpha, beta, gamma) -&gt; &#39;LatticeParameters&#39;:
        &#34;&#34;&#34;Initialize with triclinic constraints.&#34;&#34;&#34;
        return cls(a, b, c, alpha, beta, gamma)

    @classmethod
    def monoclinic(cls, a, b, c, beta) -&gt; &#39;LatticeParameters&#39;:
        &#34;&#34;&#34;Initialize with monoclinic constraints.&#34;&#34;&#34;
        return cls(a, b, c, DEG90, beta, DEG90)

    @classmethod
    def orthorhombic(cls, a, b, c) -&gt; &#39;LatticeParameters&#39;:
        &#34;&#34;&#34;Initialize with orthorhombic constraints.&#34;&#34;&#34;
        return cls(a, b, c, DEG90, DEG90, DEG90)

    @classmethod
    def tetragonal(cls, a, c) -&gt; &#39;LatticeParameters&#39;:
        &#34;&#34;&#34;Initialize with tetragonal constraints.&#34;&#34;&#34;
        return cls(a, a, c, DEG90, DEG90, DEG90)

    @classmethod
    def trigonal(cls, a, c) -&gt; &#39;LatticeParameters&#39;:
        &#34;&#34;&#34;Initialize with trigonal constraints.&#34;&#34;&#34;
        return cls(a, a, c, DEG90, DEG90, DEG120)

    @classmethod
    def rhombohedral(cls, a, alpha) -&gt; &#39;LatticeParameters&#39;:
        &#34;&#34;&#34;Initialize with rhombohedral constraints.&#34;&#34;&#34;
        return cls(a, a, a, alpha, alpha, alpha)

    @classmethod
    def hexagonal(cls, a, c) -&gt; &#39;LatticeParameters&#39;:
        &#34;&#34;&#34;Initialize with hexagonal constraints.&#34;&#34;&#34;
        return cls(a, a, c, DEG90, DEG90, DEG120)

    @classmethod
    def cubic(cls, a) -&gt; &#39;LatticeParameters&#39;:
        &#34;&#34;&#34;Initialize with cubic constraints.&#34;&#34;&#34;
        return cls(a, a, a, DEG90, DEG90, DEG90)

    ####################
    #    Properties    #
    ####################

    @property
    def metric_tensor(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns the metric tensor defined by the lattice parameters.&#34;&#34;&#34;
        return np.array([[self.a * self.a, self.a * self.b * np.cos(self.gamma), self.a * self.c * np.cos(self.beta)],
                         [self.a * self.b * np.cos(self.gamma), self.b * self.b, self.b * self.c * np.cos(self.alpha)],
                         [self.a * self.c * np.cos(self.beta), self.b * self.c * np.cos(self.alpha), self.c * self.c]])</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="atompack.crystal.LatticeParameters.cubic"><code class="name flex">
<span>def <span class="ident">cubic</span></span>(<span>a) ‑> <a title="atompack.crystal.LatticeParameters" href="#atompack.crystal.LatticeParameters">LatticeParameters</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initialize with cubic constraints.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cubic(cls, a) -&gt; &#39;LatticeParameters&#39;:
    &#34;&#34;&#34;Initialize with cubic constraints.&#34;&#34;&#34;
    return cls(a, a, a, DEG90, DEG90, DEG90)</code></pre>
</details>
</dd>
<dt id="atompack.crystal.LatticeParameters.hexagonal"><code class="name flex">
<span>def <span class="ident">hexagonal</span></span>(<span>a, c) ‑> <a title="atompack.crystal.LatticeParameters" href="#atompack.crystal.LatticeParameters">LatticeParameters</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initialize with hexagonal constraints.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def hexagonal(cls, a, c) -&gt; &#39;LatticeParameters&#39;:
    &#34;&#34;&#34;Initialize with hexagonal constraints.&#34;&#34;&#34;
    return cls(a, a, c, DEG90, DEG90, DEG120)</code></pre>
</details>
</dd>
<dt id="atompack.crystal.LatticeParameters.monoclinic"><code class="name flex">
<span>def <span class="ident">monoclinic</span></span>(<span>a, b, c, beta) ‑> <a title="atompack.crystal.LatticeParameters" href="#atompack.crystal.LatticeParameters">LatticeParameters</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initialize with monoclinic constraints.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def monoclinic(cls, a, b, c, beta) -&gt; &#39;LatticeParameters&#39;:
    &#34;&#34;&#34;Initialize with monoclinic constraints.&#34;&#34;&#34;
    return cls(a, b, c, DEG90, beta, DEG90)</code></pre>
</details>
</dd>
<dt id="atompack.crystal.LatticeParameters.orthorhombic"><code class="name flex">
<span>def <span class="ident">orthorhombic</span></span>(<span>a, b, c) ‑> <a title="atompack.crystal.LatticeParameters" href="#atompack.crystal.LatticeParameters">LatticeParameters</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initialize with orthorhombic constraints.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def orthorhombic(cls, a, b, c) -&gt; &#39;LatticeParameters&#39;:
    &#34;&#34;&#34;Initialize with orthorhombic constraints.&#34;&#34;&#34;
    return cls(a, b, c, DEG90, DEG90, DEG90)</code></pre>
</details>
</dd>
<dt id="atompack.crystal.LatticeParameters.rhombohedral"><code class="name flex">
<span>def <span class="ident">rhombohedral</span></span>(<span>a, alpha) ‑> <a title="atompack.crystal.LatticeParameters" href="#atompack.crystal.LatticeParameters">LatticeParameters</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initialize with rhombohedral constraints.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def rhombohedral(cls, a, alpha) -&gt; &#39;LatticeParameters&#39;:
    &#34;&#34;&#34;Initialize with rhombohedral constraints.&#34;&#34;&#34;
    return cls(a, a, a, alpha, alpha, alpha)</code></pre>
</details>
</dd>
<dt id="atompack.crystal.LatticeParameters.tetragonal"><code class="name flex">
<span>def <span class="ident">tetragonal</span></span>(<span>a, c) ‑> <a title="atompack.crystal.LatticeParameters" href="#atompack.crystal.LatticeParameters">LatticeParameters</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initialize with tetragonal constraints.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def tetragonal(cls, a, c) -&gt; &#39;LatticeParameters&#39;:
    &#34;&#34;&#34;Initialize with tetragonal constraints.&#34;&#34;&#34;
    return cls(a, a, c, DEG90, DEG90, DEG90)</code></pre>
</details>
</dd>
<dt id="atompack.crystal.LatticeParameters.triclinic"><code class="name flex">
<span>def <span class="ident">triclinic</span></span>(<span>a, b, c, alpha, beta, gamma) ‑> <a title="atompack.crystal.LatticeParameters" href="#atompack.crystal.LatticeParameters">LatticeParameters</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initialize with triclinic constraints.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def triclinic(cls, a, b, c, alpha, beta, gamma) -&gt; &#39;LatticeParameters&#39;:
    &#34;&#34;&#34;Initialize with triclinic constraints.&#34;&#34;&#34;
    return cls(a, b, c, alpha, beta, gamma)</code></pre>
</details>
</dd>
<dt id="atompack.crystal.LatticeParameters.trigonal"><code class="name flex">
<span>def <span class="ident">trigonal</span></span>(<span>a, c) ‑> <a title="atompack.crystal.LatticeParameters" href="#atompack.crystal.LatticeParameters">LatticeParameters</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initialize with trigonal constraints.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def trigonal(cls, a, c) -&gt; &#39;LatticeParameters&#39;:
    &#34;&#34;&#34;Initialize with trigonal constraints.&#34;&#34;&#34;
    return cls(a, a, c, DEG90, DEG90, DEG120)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="atompack.crystal.LatticeParameters.metric_tensor"><code class="name">var <span class="ident">metric_tensor</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Returns the metric tensor defined by the lattice parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def metric_tensor(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Returns the metric tensor defined by the lattice parameters.&#34;&#34;&#34;
    return np.array([[self.a * self.a, self.a * self.b * np.cos(self.gamma), self.a * self.c * np.cos(self.beta)],
                     [self.a * self.b * np.cos(self.gamma), self.b * self.b, self.b * self.c * np.cos(self.alpha)],
                     [self.a * self.c * np.cos(self.beta), self.b * self.c * np.cos(self.alpha), self.c * self.c]])</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="atompack.crystal.Orientation"><code class="flex name class">
<span>class <span class="ident">Orientation</span></span>
<span>(</span><span>quat, normalize=True, copy=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Representation of a crystallographic orientation.
This class inherits from <code>scipy.spatial.transform.Rotation</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Orientation(Rotation):
    &#34;&#34;&#34;Representation of a crystallographic orientation.
    This class inherits from `scipy.spatial.transform.Rotation`.
    &#34;&#34;&#34;

    ######################
    #    Constructors    #
    ######################

    @classmethod
    def from_miller_indices(cls, hkl: Tuple[int, int, int], uvw: Tuple[int, int, int]) -&gt; &#39;Orientation&#39;:
        &#34;&#34;&#34;Initialize from Miller Indices.
        
        Args:
            hkl: Indices of the plane.
            uvw: Indices of the direction.
        &#34;&#34;&#34;
        pass

    ########################
    #    Public Methods    #
    ########################

    def as_miller_indices(self) -&gt; Tuple[Tuple[int, int, int], Tuple[int, int, int]]:
        &#34;&#34;&#34;Represent as Miller Indices.&#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scipy.spatial.transform.rotation.Rotation</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="atompack.crystal.Orientation.from_miller_indices"><code class="name flex">
<span>def <span class="ident">from_miller_indices</span></span>(<span>hkl: Tuple[int, int, int], uvw: Tuple[int, int, int]) ‑> <a title="atompack.crystal.Orientation" href="#atompack.crystal.Orientation">Orientation</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initialize from Miller Indices.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>hkl</code></strong></dt>
<dd>Indices of the plane.</dd>
<dt><strong><code>uvw</code></strong></dt>
<dd>Indices of the direction.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_miller_indices(cls, hkl: Tuple[int, int, int], uvw: Tuple[int, int, int]) -&gt; &#39;Orientation&#39;:
    &#34;&#34;&#34;Initialize from Miller Indices.
    
    Args:
        hkl: Indices of the plane.
        uvw: Indices of the direction.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="atompack.crystal.Orientation.as_miller_indices"><code class="name flex">
<span>def <span class="ident">as_miller_indices</span></span>(<span>self) ‑> Tuple[Tuple[int, int, int], Tuple[int, int, int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Represent as Miller Indices.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_miller_indices(self) -&gt; Tuple[Tuple[int, int, int], Tuple[int, int, int]]:
    &#34;&#34;&#34;Represent as Miller Indices.&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="atompack.crystal.Plane"><code class="flex name class">
<span>class <span class="ident">Plane</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Plane(object):

    ######################
    #    Constructors    #
    ######################

    @classmethod
    def from_miller_indices(cls, hkl: Tuple[int, int, int]) -&gt; &#39;Plane&#39;:
        &#34;&#34;&#34;Initialize from Miller Indices.&#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="atompack.crystal.Plane.from_miller_indices"><code class="name flex">
<span>def <span class="ident">from_miller_indices</span></span>(<span>hkl: Tuple[int, int, int]) ‑> <a title="atompack.crystal.Plane" href="#atompack.crystal.Plane">Plane</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initialize from Miller Indices.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_miller_indices(cls, hkl: Tuple[int, int, int]) -&gt; &#39;Plane&#39;:
    &#34;&#34;&#34;Initialize from Miller Indices.&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="atompack.crystal.UnitCell"><code class="flex name class">
<span>class <span class="ident">UnitCell</span></span>
<span>(</span><span>basis: <a title="atompack.crystal.Basis" href="#atompack.crystal.Basis">Basis</a>, lattice_parameters: <a title="atompack.crystal.LatticeParameters" href="#atompack.crystal.LatticeParameters">LatticeParameters</a>, spacegroup: <a title="atompack.spacegroup.Spacegroup" href="spacegroup.html#atompack.spacegroup.Spacegroup">Spacegroup</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Minimal representation of a crystalline structure.</p>
<h2 id="note">Note</h2>
<p>End users should not construct unit cell objects directly.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>basis</code></strong></dt>
<dd>Asymmetric site occupancy.</dd>
<dt><strong><code>lattice_parameters</code></strong></dt>
<dd>Lattice parameters object.</dd>
<dt><strong><code>spacegroup</code></strong></dt>
<dd>Spacegroup object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnitCell(Topology):
    &#34;&#34;&#34;Minimal representation of a crystalline structure.

    Note:
        End users should not construct unit cell objects directly.
    
    Args:
        basis: Asymmetric site occupancy.
        lattice_parameters: Lattice parameters object.
        spacegroup: Spacegroup object.
    &#34;&#34;&#34;

    def __init__(self, basis: Basis, lattice_parameters: LatticeParameters, spacegroup: Spacegroup) -&gt; None:
        super().__init__()
        self._basis = basis
        self._lattice_parameters = lattice_parameters
        self._spacegroup = spacegroup
        self._build()

    ####################
    #    Properties    #
    ####################

    @property
    def basis(self) -&gt; Basis:
        &#34;&#34;&#34;Returns the basis.&#34;&#34;&#34;
        return self._basis

    @property
    def lattice_parameters(self) -&gt; LatticeParameters:
        &#34;&#34;&#34;Returns the lattice parameters.&#34;&#34;&#34;
        return self._lattice_parameters
    
    @property
    def lattice_vectors(self) -&gt; np.ndarray:
        return np.sqrt(np.abs(self.lattice_parameters.metric_tensor))

    @property
    def spacegroup(self) -&gt; Spacegroup:
        &#34;&#34;&#34;Returns the spacegroup.&#34;&#34;&#34;
        return self._spacegroup

    #########################
    #    Private Methods    #
    #########################

    def _build(self) -&gt; None:
        for site, specie in self.basis.apply_spacegroup(self.spacegroup):
            position = site * np.linalg.norm(self.lattice_vectors, axis=0)
            self.atoms.append(Atom(position, specie))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="atompack.topology.Topology" href="topology.html#atompack.topology.Topology">Topology</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="atompack.crystal.UnitCell.basis"><code class="name">var <span class="ident">basis</span> : <a title="atompack.crystal.Basis" href="#atompack.crystal.Basis">Basis</a></code></dt>
<dd>
<div class="desc"><p>Returns the basis.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def basis(self) -&gt; Basis:
    &#34;&#34;&#34;Returns the basis.&#34;&#34;&#34;
    return self._basis</code></pre>
</details>
</dd>
<dt id="atompack.crystal.UnitCell.lattice_parameters"><code class="name">var <span class="ident">lattice_parameters</span> : <a title="atompack.crystal.LatticeParameters" href="#atompack.crystal.LatticeParameters">LatticeParameters</a></code></dt>
<dd>
<div class="desc"><p>Returns the lattice parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lattice_parameters(self) -&gt; LatticeParameters:
    &#34;&#34;&#34;Returns the lattice parameters.&#34;&#34;&#34;
    return self._lattice_parameters</code></pre>
</details>
</dd>
<dt id="atompack.crystal.UnitCell.lattice_vectors"><code class="name">var <span class="ident">lattice_vectors</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lattice_vectors(self) -&gt; np.ndarray:
    return np.sqrt(np.abs(self.lattice_parameters.metric_tensor))</code></pre>
</details>
</dd>
<dt id="atompack.crystal.UnitCell.spacegroup"><code class="name">var <span class="ident">spacegroup</span> : <a title="atompack.spacegroup.Spacegroup" href="spacegroup.html#atompack.spacegroup.Spacegroup">Spacegroup</a></code></dt>
<dd>
<div class="desc"><p>Returns the spacegroup.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spacegroup(self) -&gt; Spacegroup:
    &#34;&#34;&#34;Returns the spacegroup.&#34;&#34;&#34;
    return self._spacegroup</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="atompack.topology.Topology" href="topology.html#atompack.topology.Topology">Topology</a></b></code>:
<ul class="hlist">
<li><code><a title="atompack.topology.Topology.atoms" href="topology.html#atompack.topology.Topology.atoms">atoms</a></code></li>
<li><code><a title="atompack.topology.Topology.bonds" href="topology.html#atompack.topology.Topology.bonds">bonds</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="atompack" href="index.html">atompack</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="atompack.crystal.Basis" href="#atompack.crystal.Basis">Basis</a></code></h4>
<ul class="">
<li><code><a title="atompack.crystal.Basis.apply_spacegroup" href="#atompack.crystal.Basis.apply_spacegroup">apply_spacegroup</a></code></li>
<li><code><a title="atompack.crystal.Basis.insert" href="#atompack.crystal.Basis.insert">insert</a></code></li>
<li><code><a title="atompack.crystal.Basis.primitive" href="#atompack.crystal.Basis.primitive">primitive</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></code></h4>
<ul class="two-column">
<li><code><a title="atompack.crystal.Crystal.cut" href="#atompack.crystal.Crystal.cut">cut</a></code></li>
<li><code><a title="atompack.crystal.Crystal.finish" href="#atompack.crystal.Crystal.finish">finish</a></code></li>
<li><code><a title="atompack.crystal.Crystal.general_transform" href="#atompack.crystal.Crystal.general_transform">general_transform</a></code></li>
<li><code><a title="atompack.crystal.Crystal.lattice_vectors" href="#atompack.crystal.Crystal.lattice_vectors">lattice_vectors</a></code></li>
<li><code><a title="atompack.crystal.Crystal.orient" href="#atompack.crystal.Crystal.orient">orient</a></code></li>
<li><code><a title="atompack.crystal.Crystal.project" href="#atompack.crystal.Crystal.project">project</a></code></li>
<li><code><a title="atompack.crystal.Crystal.supercell" href="#atompack.crystal.Crystal.supercell">supercell</a></code></li>
<li><code><a title="atompack.crystal.Crystal.unit_cell" href="#atompack.crystal.Crystal.unit_cell">unit_cell</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="atompack.crystal.LatticeParameters" href="#atompack.crystal.LatticeParameters">LatticeParameters</a></code></h4>
<ul class="two-column">
<li><code><a title="atompack.crystal.LatticeParameters.cubic" href="#atompack.crystal.LatticeParameters.cubic">cubic</a></code></li>
<li><code><a title="atompack.crystal.LatticeParameters.hexagonal" href="#atompack.crystal.LatticeParameters.hexagonal">hexagonal</a></code></li>
<li><code><a title="atompack.crystal.LatticeParameters.metric_tensor" href="#atompack.crystal.LatticeParameters.metric_tensor">metric_tensor</a></code></li>
<li><code><a title="atompack.crystal.LatticeParameters.monoclinic" href="#atompack.crystal.LatticeParameters.monoclinic">monoclinic</a></code></li>
<li><code><a title="atompack.crystal.LatticeParameters.orthorhombic" href="#atompack.crystal.LatticeParameters.orthorhombic">orthorhombic</a></code></li>
<li><code><a title="atompack.crystal.LatticeParameters.rhombohedral" href="#atompack.crystal.LatticeParameters.rhombohedral">rhombohedral</a></code></li>
<li><code><a title="atompack.crystal.LatticeParameters.tetragonal" href="#atompack.crystal.LatticeParameters.tetragonal">tetragonal</a></code></li>
<li><code><a title="atompack.crystal.LatticeParameters.triclinic" href="#atompack.crystal.LatticeParameters.triclinic">triclinic</a></code></li>
<li><code><a title="atompack.crystal.LatticeParameters.trigonal" href="#atompack.crystal.LatticeParameters.trigonal">trigonal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="atompack.crystal.Orientation" href="#atompack.crystal.Orientation">Orientation</a></code></h4>
<ul class="">
<li><code><a title="atompack.crystal.Orientation.as_miller_indices" href="#atompack.crystal.Orientation.as_miller_indices">as_miller_indices</a></code></li>
<li><code><a title="atompack.crystal.Orientation.from_miller_indices" href="#atompack.crystal.Orientation.from_miller_indices">from_miller_indices</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="atompack.crystal.Plane" href="#atompack.crystal.Plane">Plane</a></code></h4>
<ul class="">
<li><code><a title="atompack.crystal.Plane.from_miller_indices" href="#atompack.crystal.Plane.from_miller_indices">from_miller_indices</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="atompack.crystal.UnitCell" href="#atompack.crystal.UnitCell">UnitCell</a></code></h4>
<ul class="">
<li><code><a title="atompack.crystal.UnitCell.basis" href="#atompack.crystal.UnitCell.basis">basis</a></code></li>
<li><code><a title="atompack.crystal.UnitCell.lattice_parameters" href="#atompack.crystal.UnitCell.lattice_parameters">lattice_parameters</a></code></li>
<li><code><a title="atompack.crystal.UnitCell.lattice_vectors" href="#atompack.crystal.UnitCell.lattice_vectors">lattice_vectors</a></code></li>
<li><code><a title="atompack.crystal.UnitCell.spacegroup" href="#atompack.crystal.UnitCell.spacegroup">spacegroup</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>