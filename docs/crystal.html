<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>atompack.crystal API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>atompack.crystal</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import copy
from typing import List, Optional, Tuple

import numpy as np
from scipy.spatial.transform import Rotation

from atompack.atom import Atom, AtomCollection
from atompack.error import (InvalidHexagonalError, InvalidMonoclinicError, InvalidOrthorhombicError,
                            InvalidRhombohedralError, InvalidTetragonalError, InvalidTriclinicError)
from atompack.internal import metric_tensor, search_for_atom


class Crystal(AtomCollection):
    &#34;&#34;&#34;A crystalline lattice.

    Args:
        a: The \\(a\\) distance lattice parameter.
        b: The \\(b\\) distance lattice parameter.
        c: The \\(c\\) distance lattice parameter.
        alpha: The \\(\\alpha\\) angle lattice parameter.
        beta: The \\(\\beta\\) angle lattice parameter.
        gamma: The \\(\\gamma\\) angle lattice parameter.
        unit_cell: A template of atoms and their basis sites to be repeated during construction.
        orientation: The orientation of the basis.
        rotation: A rotation matrix which rotates the final structure.
        size: The number of units to repeat in each spatial direction.
    &#34;&#34;&#34;

    def __init__(self,
                 a: float = 0,
                 b: float = 0,
                 c: float = 0,
                 alpha: float = 0,
                 beta: float = 0,
                 gamma: float = 0,
                 unit_cell: Optional[List[Tuple[Atom, np.ndarray]]] = None,
                 orientation: Optional[np.ndarray] = None,
                 rotation: Optional[np.ndarray] = None,
                 size: Optional[Tuple[int, int, int]] = None) -&gt; None:
        self._a, self._b, self._c = a, b, c
        self._alpha, self._beta, self._gamma = alpha, beta, gamma
        self._unit_cell = unit_cell
        self._orientation = orientation
        self._rotation = rotation
        self._size = size
        atoms, basis = self._build()
        super().__init__(atoms=atoms, basis=basis)

    @classmethod
    def triclinic(cls,
                  a: float,
                  b: float,
                  c: float,
                  alpha: float,
                  beta: float,
                  gamma: float,
                  unit_cell: List[Tuple[Atom, np.ndarray]],
                  orientation: Optional[np.ndarray] = None,
                  rotation: Optional[np.ndarray] = None,
                  size: Optional[Tuple[int, int, int]] = None) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes a `Crystal` with triclinic constraints.
        
        Raises:
            `atompack.error.InvalidTriclinicError`: Triclinic constraints are not satisfied.
        &#34;&#34;&#34;
        if not (a != b != c):
            raise InvalidTriclinicError(a, b, c, alpha, beta, gamma)
        if not (alpha != beta != gamma):
            raise InvalidTriclinicError(a, b, c, alpha, beta, gamma)
        return cls(a, b, c, alpha, beta, gamma, unit_cell, orientation, rotation, size)

    @classmethod
    def monoclinic(cls,
                   a: float,
                   b: float,
                   c: float,
                   beta: float,
                   unit_cell: List[Tuple[Atom, np.ndarray]],
                   orientation: Optional[np.ndarray] = None,
                   rotation: Optional[np.ndarray] = None,
                   size: Optional[Tuple[int, int, int]] = None) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes a `Crystal` with monoclinic constraints.
        
        Raises:
            `atompack.error.InvalidMonoclinicError`: Monoclinic constraints are not satisfied.
        &#34;&#34;&#34;
        alpha, gamma = np.pi / 2, np.pi / 2
        if not (a != b != c):
            raise InvalidMonoclinicError(a, b, c, alpha, beta, gamma)
        if beta == np.pi / 2:
            raise InvalidMonoclinicError(a, b, c, alpha, beta, gamma)
        return cls(a, b, c, alpha, beta, gamma, unit_cell, orientation, rotation, size)

    @classmethod
    def orthorhombic(cls,
                     a: float,
                     b: float,
                     c: float,
                     unit_cell: List[Tuple[Atom, np.ndarray]],
                     orientation: Optional[np.ndarray] = None,
                     rotation: Optional[np.ndarray] = None,
                     size: Optional[Tuple[int, int, int]] = None) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes a `Crystal` with orthorhombic constraints.
        
        Raises:
            `atompack.error.InvalidOrthorhombicError`: Orthorhombic constraints are not satisfied.
        &#34;&#34;&#34;
        alpha, beta, gamma = np.pi / 2, np.pi / 2, np.pi / 2
        if not (a != b != c):
            raise InvalidOrthorhombicError(a, b, c, alpha, beta, gamma)
        return cls(a, b, c, alpha, beta, gamma, unit_cell, orientation, rotation, size)

    @classmethod
    def tetragonal(cls,
                   a: float,
                   c: float,
                   unit_cell: List[Tuple[Atom, np.ndarray]],
                   orientation: Optional[np.ndarray] = None,
                   rotation: Optional[np.ndarray] = None,
                   size: Optional[Tuple[int, int, int]] = None) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes a `Crystal` with tetragonal constraints.
        
        Raises:
            `atompack.error.InvalidTetragonalError`: Tetragonal constraints are not satisfied.
        &#34;&#34;&#34;
        b = a
        alpha, beta, gamma = np.pi / 2, np.pi / 2, np.pi / 2
        if a == c:
            raise InvalidTetragonalError(a, b, c, alpha, beta, gamma)
        return cls(a, b, c, alpha, beta, gamma, unit_cell, orientation, rotation, size)

    @classmethod
    def rhombohedral(cls,
                     a: float,
                     alpha: float,
                     unit_cell: List[Tuple[Atom, np.ndarray]],
                     orientation: Optional[np.ndarray] = None,
                     rotation: Optional[np.ndarray] = None,
                     size: Optional[Tuple[int, int, int]] = None) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes a `Crystal` with rhombohedral constraints.
        
        Raises:
            `atompack.error.InvalidRhombohedralError`: Rhombohedral constraints are not satisfied.
        &#34;&#34;&#34;
        b, c = a, a
        beta, gamma = alpha, alpha
        if alpha == np.pi / 2:
            raise InvalidRhombohedralError(a, b, c, alpha, beta, gamma)
        return cls(a, b, c, alpha, beta, gamma, unit_cell, orientation, rotation, size)

    @classmethod
    def hexagonal(cls,
                  a: float,
                  c: float,
                  unit_cell: List[Tuple[Atom, np.ndarray]],
                  orientation: Optional[np.ndarray] = None,
                  rotation: Optional[np.ndarray] = None,
                  size: Optional[Tuple[int, int, int]] = None) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes a `Crystal` with hexagonal constraints.
        
        Raises:
            `atompack.error.InvalidHexagonalError`: Hexagonal constraints are not satisfied.
        &#34;&#34;&#34;
        b = a
        alpha, beta, gamma = np.pi / 2, 120 * np.pi / 180, np.pi / 2
        if a == c:
            raise InvalidHexagonalError(a, b, c, alpha, beta, gamma)
        return cls(a, b, c, alpha, beta, gamma, unit_cell, orientation, rotation, size)

    @classmethod
    def cubic(cls,
              a: float,
              unit_cell: List[Tuple[Atom, np.ndarray]],
              orientation: Optional[np.ndarray] = None,
              rotation: Optional[np.ndarray] = None,
              size: Optional[Tuple[int, int, int]] = None) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes a `Crystal` with cubic constraints.&#34;&#34;&#34;
        b, c = a, a
        alpha, beta, gamma = np.pi / 2, np.pi / 2, np.pi / 2
        return cls(a, b, c, alpha, beta, gamma, unit_cell, orientation, rotation, size)

    def _build(self) -&gt; Tuple[List[Atom], np.ndarray]:
        # generate lattice vectors from metric tensor
        lattice_vectors = np.sqrt(metric_tensor(self._a, self._b, self._c, self._alpha, self._beta, self._gamma))

        # process attributes
        if self._unit_cell is None:
            self._unit_cell = [(Atom(), np.zeros((3,)))]
        if self._orientation is None:
            self._orientation = lattice_vectors
        if self._rotation is None:
            self._rotation = np.identity(3)
        else:
            raise NotImplementedError()
        if self._size is None:
            self._size = (1, 1, 1)

        # generate the rotation between the lattice vectors and new orientation
        rotation = Rotation.align_vectors(lattice_vectors, self._orientation)[0]

        # align lattice vectors with orientation
        oriented_lattice_vectors = np.matmul(self._orientation, lattice_vectors)

        # use QR decomposition to determine an orthogonal representation of the oriented lattice vectors
        _, r = np.linalg.qr(oriented_lattice_vectors.T)
        oriented_lattice_vectors = np.abs(r) * np.array(self._size)
        oriented_lattice_magnitudes = np.linalg.norm(oriented_lattice_vectors, axis=0)

        # determine the smallest required orthogonal cell
        # TODO: determine optimal scaling factor
        scaling_factor = 2
        minimum_orthogonal_size = (np.ceil(np.linalg.norm(r, axis=0)) *
                                   np.array(self._size)).astype(int) * scaling_factor

        # place atoms on the oriented lattice vectors
        atoms: List[Atom] = []
        for xsize in range(minimum_orthogonal_size[0]):
            for ysize in range(minimum_orthogonal_size[1]):
                for zsize in range(minimum_orthogonal_size[2]):
                    offset = np.matmul(np.array([xsize, ysize, zsize]), lattice_vectors)
                    for atom, relative_position in self._unit_cell:

                        # assign the cartesian position
                        position = np.matmul(relative_position, lattice_vectors) + offset
                        position = rotation.apply(position)

                        # transform the position back into the bounding box
                        for i in range(3):
                            if position[i] &lt; -1e-6:
                                new_position = position[i]
                                while new_position &lt; -1e-6:
                                    new_position += oriented_lattice_magnitudes[i]
                                position[i] = new_position
                            elif position[i] &gt;= oriented_lattice_magnitudes[i] - 1e-6:
                                new_position = position[i]
                                while new_position &gt;= oriented_lattice_magnitudes[i] - 1e-6:
                                    new_position -= oriented_lattice_magnitudes[i]
                                position[i] = new_position

                        # accept the atom if the position is not occupied
                        res = search_for_atom(atoms, position, 1e-6)
                        if res is None:
                            new_atom = copy.deepcopy(atom)
                            new_atom.position = position
                            atoms.append(new_atom)

        # TODO: implement rotation
        return atoms, oriented_lattice_vectors</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="atompack.crystal.Crystal"><code class="flex name class">
<span>class <span class="ident">Crystal</span></span>
<span>(</span><span>a: float = 0, b: float = 0, c: float = 0, alpha: float = 0, beta: float = 0, gamma: float = 0, unit_cell: Union[List[Tuple[atompack.atom.Atom, numpy.ndarray]], NoneType] = None, orientation: Union[numpy.ndarray, NoneType] = None, rotation: Union[numpy.ndarray, NoneType] = None, size: Union[Tuple[int, int, int], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A crystalline lattice.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>a</code></strong></dt>
<dd>The <span><span class="MathJax_Preview">a</span><script type="math/tex">a</script></span> distance lattice parameter.</dd>
<dt><strong><code>b</code></strong></dt>
<dd>The <span><span class="MathJax_Preview">b</span><script type="math/tex">b</script></span> distance lattice parameter.</dd>
<dt><strong><code>c</code></strong></dt>
<dd>The <span><span class="MathJax_Preview">c</span><script type="math/tex">c</script></span> distance lattice parameter.</dd>
<dt><strong><code>alpha</code></strong></dt>
<dd>The <span><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span> angle lattice parameter.</dd>
<dt><strong><code>beta</code></strong></dt>
<dd>The <span><span class="MathJax_Preview">\beta</span><script type="math/tex">\beta</script></span> angle lattice parameter.</dd>
<dt><strong><code>gamma</code></strong></dt>
<dd>The <span><span class="MathJax_Preview">\gamma</span><script type="math/tex">\gamma</script></span> angle lattice parameter.</dd>
<dt><strong><code>unit_cell</code></strong></dt>
<dd>A template of atoms and their basis sites to be repeated during construction.</dd>
<dt><strong><code>orientation</code></strong></dt>
<dd>The orientation of the basis.</dd>
<dt><strong><code>rotation</code></strong></dt>
<dd>A rotation matrix which rotates the final structure.</dd>
<dt><strong><code>size</code></strong></dt>
<dd>The number of units to repeat in each spatial direction.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Crystal(AtomCollection):
    &#34;&#34;&#34;A crystalline lattice.

    Args:
        a: The \\(a\\) distance lattice parameter.
        b: The \\(b\\) distance lattice parameter.
        c: The \\(c\\) distance lattice parameter.
        alpha: The \\(\\alpha\\) angle lattice parameter.
        beta: The \\(\\beta\\) angle lattice parameter.
        gamma: The \\(\\gamma\\) angle lattice parameter.
        unit_cell: A template of atoms and their basis sites to be repeated during construction.
        orientation: The orientation of the basis.
        rotation: A rotation matrix which rotates the final structure.
        size: The number of units to repeat in each spatial direction.
    &#34;&#34;&#34;

    def __init__(self,
                 a: float = 0,
                 b: float = 0,
                 c: float = 0,
                 alpha: float = 0,
                 beta: float = 0,
                 gamma: float = 0,
                 unit_cell: Optional[List[Tuple[Atom, np.ndarray]]] = None,
                 orientation: Optional[np.ndarray] = None,
                 rotation: Optional[np.ndarray] = None,
                 size: Optional[Tuple[int, int, int]] = None) -&gt; None:
        self._a, self._b, self._c = a, b, c
        self._alpha, self._beta, self._gamma = alpha, beta, gamma
        self._unit_cell = unit_cell
        self._orientation = orientation
        self._rotation = rotation
        self._size = size
        atoms, basis = self._build()
        super().__init__(atoms=atoms, basis=basis)

    @classmethod
    def triclinic(cls,
                  a: float,
                  b: float,
                  c: float,
                  alpha: float,
                  beta: float,
                  gamma: float,
                  unit_cell: List[Tuple[Atom, np.ndarray]],
                  orientation: Optional[np.ndarray] = None,
                  rotation: Optional[np.ndarray] = None,
                  size: Optional[Tuple[int, int, int]] = None) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes a `Crystal` with triclinic constraints.
        
        Raises:
            `atompack.error.InvalidTriclinicError`: Triclinic constraints are not satisfied.
        &#34;&#34;&#34;
        if not (a != b != c):
            raise InvalidTriclinicError(a, b, c, alpha, beta, gamma)
        if not (alpha != beta != gamma):
            raise InvalidTriclinicError(a, b, c, alpha, beta, gamma)
        return cls(a, b, c, alpha, beta, gamma, unit_cell, orientation, rotation, size)

    @classmethod
    def monoclinic(cls,
                   a: float,
                   b: float,
                   c: float,
                   beta: float,
                   unit_cell: List[Tuple[Atom, np.ndarray]],
                   orientation: Optional[np.ndarray] = None,
                   rotation: Optional[np.ndarray] = None,
                   size: Optional[Tuple[int, int, int]] = None) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes a `Crystal` with monoclinic constraints.
        
        Raises:
            `atompack.error.InvalidMonoclinicError`: Monoclinic constraints are not satisfied.
        &#34;&#34;&#34;
        alpha, gamma = np.pi / 2, np.pi / 2
        if not (a != b != c):
            raise InvalidMonoclinicError(a, b, c, alpha, beta, gamma)
        if beta == np.pi / 2:
            raise InvalidMonoclinicError(a, b, c, alpha, beta, gamma)
        return cls(a, b, c, alpha, beta, gamma, unit_cell, orientation, rotation, size)

    @classmethod
    def orthorhombic(cls,
                     a: float,
                     b: float,
                     c: float,
                     unit_cell: List[Tuple[Atom, np.ndarray]],
                     orientation: Optional[np.ndarray] = None,
                     rotation: Optional[np.ndarray] = None,
                     size: Optional[Tuple[int, int, int]] = None) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes a `Crystal` with orthorhombic constraints.
        
        Raises:
            `atompack.error.InvalidOrthorhombicError`: Orthorhombic constraints are not satisfied.
        &#34;&#34;&#34;
        alpha, beta, gamma = np.pi / 2, np.pi / 2, np.pi / 2
        if not (a != b != c):
            raise InvalidOrthorhombicError(a, b, c, alpha, beta, gamma)
        return cls(a, b, c, alpha, beta, gamma, unit_cell, orientation, rotation, size)

    @classmethod
    def tetragonal(cls,
                   a: float,
                   c: float,
                   unit_cell: List[Tuple[Atom, np.ndarray]],
                   orientation: Optional[np.ndarray] = None,
                   rotation: Optional[np.ndarray] = None,
                   size: Optional[Tuple[int, int, int]] = None) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes a `Crystal` with tetragonal constraints.
        
        Raises:
            `atompack.error.InvalidTetragonalError`: Tetragonal constraints are not satisfied.
        &#34;&#34;&#34;
        b = a
        alpha, beta, gamma = np.pi / 2, np.pi / 2, np.pi / 2
        if a == c:
            raise InvalidTetragonalError(a, b, c, alpha, beta, gamma)
        return cls(a, b, c, alpha, beta, gamma, unit_cell, orientation, rotation, size)

    @classmethod
    def rhombohedral(cls,
                     a: float,
                     alpha: float,
                     unit_cell: List[Tuple[Atom, np.ndarray]],
                     orientation: Optional[np.ndarray] = None,
                     rotation: Optional[np.ndarray] = None,
                     size: Optional[Tuple[int, int, int]] = None) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes a `Crystal` with rhombohedral constraints.
        
        Raises:
            `atompack.error.InvalidRhombohedralError`: Rhombohedral constraints are not satisfied.
        &#34;&#34;&#34;
        b, c = a, a
        beta, gamma = alpha, alpha
        if alpha == np.pi / 2:
            raise InvalidRhombohedralError(a, b, c, alpha, beta, gamma)
        return cls(a, b, c, alpha, beta, gamma, unit_cell, orientation, rotation, size)

    @classmethod
    def hexagonal(cls,
                  a: float,
                  c: float,
                  unit_cell: List[Tuple[Atom, np.ndarray]],
                  orientation: Optional[np.ndarray] = None,
                  rotation: Optional[np.ndarray] = None,
                  size: Optional[Tuple[int, int, int]] = None) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes a `Crystal` with hexagonal constraints.
        
        Raises:
            `atompack.error.InvalidHexagonalError`: Hexagonal constraints are not satisfied.
        &#34;&#34;&#34;
        b = a
        alpha, beta, gamma = np.pi / 2, 120 * np.pi / 180, np.pi / 2
        if a == c:
            raise InvalidHexagonalError(a, b, c, alpha, beta, gamma)
        return cls(a, b, c, alpha, beta, gamma, unit_cell, orientation, rotation, size)

    @classmethod
    def cubic(cls,
              a: float,
              unit_cell: List[Tuple[Atom, np.ndarray]],
              orientation: Optional[np.ndarray] = None,
              rotation: Optional[np.ndarray] = None,
              size: Optional[Tuple[int, int, int]] = None) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes a `Crystal` with cubic constraints.&#34;&#34;&#34;
        b, c = a, a
        alpha, beta, gamma = np.pi / 2, np.pi / 2, np.pi / 2
        return cls(a, b, c, alpha, beta, gamma, unit_cell, orientation, rotation, size)

    def _build(self) -&gt; Tuple[List[Atom], np.ndarray]:
        # generate lattice vectors from metric tensor
        lattice_vectors = np.sqrt(metric_tensor(self._a, self._b, self._c, self._alpha, self._beta, self._gamma))

        # process attributes
        if self._unit_cell is None:
            self._unit_cell = [(Atom(), np.zeros((3,)))]
        if self._orientation is None:
            self._orientation = lattice_vectors
        if self._rotation is None:
            self._rotation = np.identity(3)
        else:
            raise NotImplementedError()
        if self._size is None:
            self._size = (1, 1, 1)

        # generate the rotation between the lattice vectors and new orientation
        rotation = Rotation.align_vectors(lattice_vectors, self._orientation)[0]

        # align lattice vectors with orientation
        oriented_lattice_vectors = np.matmul(self._orientation, lattice_vectors)

        # use QR decomposition to determine an orthogonal representation of the oriented lattice vectors
        _, r = np.linalg.qr(oriented_lattice_vectors.T)
        oriented_lattice_vectors = np.abs(r) * np.array(self._size)
        oriented_lattice_magnitudes = np.linalg.norm(oriented_lattice_vectors, axis=0)

        # determine the smallest required orthogonal cell
        # TODO: determine optimal scaling factor
        scaling_factor = 2
        minimum_orthogonal_size = (np.ceil(np.linalg.norm(r, axis=0)) *
                                   np.array(self._size)).astype(int) * scaling_factor

        # place atoms on the oriented lattice vectors
        atoms: List[Atom] = []
        for xsize in range(minimum_orthogonal_size[0]):
            for ysize in range(minimum_orthogonal_size[1]):
                for zsize in range(minimum_orthogonal_size[2]):
                    offset = np.matmul(np.array([xsize, ysize, zsize]), lattice_vectors)
                    for atom, relative_position in self._unit_cell:

                        # assign the cartesian position
                        position = np.matmul(relative_position, lattice_vectors) + offset
                        position = rotation.apply(position)

                        # transform the position back into the bounding box
                        for i in range(3):
                            if position[i] &lt; -1e-6:
                                new_position = position[i]
                                while new_position &lt; -1e-6:
                                    new_position += oriented_lattice_magnitudes[i]
                                position[i] = new_position
                            elif position[i] &gt;= oriented_lattice_magnitudes[i] - 1e-6:
                                new_position = position[i]
                                while new_position &gt;= oriented_lattice_magnitudes[i] - 1e-6:
                                    new_position -= oriented_lattice_magnitudes[i]
                                position[i] = new_position

                        # accept the atom if the position is not occupied
                        res = search_for_atom(atoms, position, 1e-6)
                        if res is None:
                            new_atom = copy.deepcopy(atom)
                            new_atom.position = position
                            atoms.append(new_atom)

        # TODO: implement rotation
        return atoms, oriented_lattice_vectors</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="atompack.atom.AtomCollection" href="atom.html#atompack.atom.AtomCollection">AtomCollection</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="atompack.crystal.Crystal.cubic"><code class="name flex">
<span>def <span class="ident">cubic</span></span>(<span>a: float, unit_cell: List[Tuple[atompack.atom.Atom, numpy.ndarray]], orientation: Union[numpy.ndarray, NoneType] = None, rotation: Union[numpy.ndarray, NoneType] = None, size: Union[Tuple[int, int, int], NoneType] = None) -> <a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a <code><a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></code> with cubic constraints.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cubic(cls,
          a: float,
          unit_cell: List[Tuple[Atom, np.ndarray]],
          orientation: Optional[np.ndarray] = None,
          rotation: Optional[np.ndarray] = None,
          size: Optional[Tuple[int, int, int]] = None) -&gt; &#39;Crystal&#39;:
    &#34;&#34;&#34;Initializes a `Crystal` with cubic constraints.&#34;&#34;&#34;
    b, c = a, a
    alpha, beta, gamma = np.pi / 2, np.pi / 2, np.pi / 2
    return cls(a, b, c, alpha, beta, gamma, unit_cell, orientation, rotation, size)</code></pre>
</details>
</dd>
<dt id="atompack.crystal.Crystal.hexagonal"><code class="name flex">
<span>def <span class="ident">hexagonal</span></span>(<span>a: float, c: float, unit_cell: List[Tuple[atompack.atom.Atom, numpy.ndarray]], orientation: Union[numpy.ndarray, NoneType] = None, rotation: Union[numpy.ndarray, NoneType] = None, size: Union[Tuple[int, int, int], NoneType] = None) -> <a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a <code><a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></code> with hexagonal constraints.</p>
<h2 id="raises">Raises</h2>
<p><code><a title="atompack.error.InvalidHexagonalError" href="error.html#atompack.error.InvalidHexagonalError">InvalidHexagonalError</a></code>: Hexagonal constraints are not satisfied.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def hexagonal(cls,
              a: float,
              c: float,
              unit_cell: List[Tuple[Atom, np.ndarray]],
              orientation: Optional[np.ndarray] = None,
              rotation: Optional[np.ndarray] = None,
              size: Optional[Tuple[int, int, int]] = None) -&gt; &#39;Crystal&#39;:
    &#34;&#34;&#34;Initializes a `Crystal` with hexagonal constraints.
    
    Raises:
        `atompack.error.InvalidHexagonalError`: Hexagonal constraints are not satisfied.
    &#34;&#34;&#34;
    b = a
    alpha, beta, gamma = np.pi / 2, 120 * np.pi / 180, np.pi / 2
    if a == c:
        raise InvalidHexagonalError(a, b, c, alpha, beta, gamma)
    return cls(a, b, c, alpha, beta, gamma, unit_cell, orientation, rotation, size)</code></pre>
</details>
</dd>
<dt id="atompack.crystal.Crystal.monoclinic"><code class="name flex">
<span>def <span class="ident">monoclinic</span></span>(<span>a: float, b: float, c: float, beta: float, unit_cell: List[Tuple[atompack.atom.Atom, numpy.ndarray]], orientation: Union[numpy.ndarray, NoneType] = None, rotation: Union[numpy.ndarray, NoneType] = None, size: Union[Tuple[int, int, int], NoneType] = None) -> <a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a <code><a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></code> with monoclinic constraints.</p>
<h2 id="raises">Raises</h2>
<p><code><a title="atompack.error.InvalidMonoclinicError" href="error.html#atompack.error.InvalidMonoclinicError">InvalidMonoclinicError</a></code>: Monoclinic constraints are not satisfied.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def monoclinic(cls,
               a: float,
               b: float,
               c: float,
               beta: float,
               unit_cell: List[Tuple[Atom, np.ndarray]],
               orientation: Optional[np.ndarray] = None,
               rotation: Optional[np.ndarray] = None,
               size: Optional[Tuple[int, int, int]] = None) -&gt; &#39;Crystal&#39;:
    &#34;&#34;&#34;Initializes a `Crystal` with monoclinic constraints.
    
    Raises:
        `atompack.error.InvalidMonoclinicError`: Monoclinic constraints are not satisfied.
    &#34;&#34;&#34;
    alpha, gamma = np.pi / 2, np.pi / 2
    if not (a != b != c):
        raise InvalidMonoclinicError(a, b, c, alpha, beta, gamma)
    if beta == np.pi / 2:
        raise InvalidMonoclinicError(a, b, c, alpha, beta, gamma)
    return cls(a, b, c, alpha, beta, gamma, unit_cell, orientation, rotation, size)</code></pre>
</details>
</dd>
<dt id="atompack.crystal.Crystal.orthorhombic"><code class="name flex">
<span>def <span class="ident">orthorhombic</span></span>(<span>a: float, b: float, c: float, unit_cell: List[Tuple[atompack.atom.Atom, numpy.ndarray]], orientation: Union[numpy.ndarray, NoneType] = None, rotation: Union[numpy.ndarray, NoneType] = None, size: Union[Tuple[int, int, int], NoneType] = None) -> <a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a <code><a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></code> with orthorhombic constraints.</p>
<h2 id="raises">Raises</h2>
<p><code><a title="atompack.error.InvalidOrthorhombicError" href="error.html#atompack.error.InvalidOrthorhombicError">InvalidOrthorhombicError</a></code>: Orthorhombic constraints are not satisfied.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def orthorhombic(cls,
                 a: float,
                 b: float,
                 c: float,
                 unit_cell: List[Tuple[Atom, np.ndarray]],
                 orientation: Optional[np.ndarray] = None,
                 rotation: Optional[np.ndarray] = None,
                 size: Optional[Tuple[int, int, int]] = None) -&gt; &#39;Crystal&#39;:
    &#34;&#34;&#34;Initializes a `Crystal` with orthorhombic constraints.
    
    Raises:
        `atompack.error.InvalidOrthorhombicError`: Orthorhombic constraints are not satisfied.
    &#34;&#34;&#34;
    alpha, beta, gamma = np.pi / 2, np.pi / 2, np.pi / 2
    if not (a != b != c):
        raise InvalidOrthorhombicError(a, b, c, alpha, beta, gamma)
    return cls(a, b, c, alpha, beta, gamma, unit_cell, orientation, rotation, size)</code></pre>
</details>
</dd>
<dt id="atompack.crystal.Crystal.rhombohedral"><code class="name flex">
<span>def <span class="ident">rhombohedral</span></span>(<span>a: float, alpha: float, unit_cell: List[Tuple[atompack.atom.Atom, numpy.ndarray]], orientation: Union[numpy.ndarray, NoneType] = None, rotation: Union[numpy.ndarray, NoneType] = None, size: Union[Tuple[int, int, int], NoneType] = None) -> <a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a <code><a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></code> with rhombohedral constraints.</p>
<h2 id="raises">Raises</h2>
<p><code><a title="atompack.error.InvalidRhombohedralError" href="error.html#atompack.error.InvalidRhombohedralError">InvalidRhombohedralError</a></code>: Rhombohedral constraints are not satisfied.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def rhombohedral(cls,
                 a: float,
                 alpha: float,
                 unit_cell: List[Tuple[Atom, np.ndarray]],
                 orientation: Optional[np.ndarray] = None,
                 rotation: Optional[np.ndarray] = None,
                 size: Optional[Tuple[int, int, int]] = None) -&gt; &#39;Crystal&#39;:
    &#34;&#34;&#34;Initializes a `Crystal` with rhombohedral constraints.
    
    Raises:
        `atompack.error.InvalidRhombohedralError`: Rhombohedral constraints are not satisfied.
    &#34;&#34;&#34;
    b, c = a, a
    beta, gamma = alpha, alpha
    if alpha == np.pi / 2:
        raise InvalidRhombohedralError(a, b, c, alpha, beta, gamma)
    return cls(a, b, c, alpha, beta, gamma, unit_cell, orientation, rotation, size)</code></pre>
</details>
</dd>
<dt id="atompack.crystal.Crystal.tetragonal"><code class="name flex">
<span>def <span class="ident">tetragonal</span></span>(<span>a: float, c: float, unit_cell: List[Tuple[atompack.atom.Atom, numpy.ndarray]], orientation: Union[numpy.ndarray, NoneType] = None, rotation: Union[numpy.ndarray, NoneType] = None, size: Union[Tuple[int, int, int], NoneType] = None) -> <a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a <code><a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></code> with tetragonal constraints.</p>
<h2 id="raises">Raises</h2>
<p><code><a title="atompack.error.InvalidTetragonalError" href="error.html#atompack.error.InvalidTetragonalError">InvalidTetragonalError</a></code>: Tetragonal constraints are not satisfied.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def tetragonal(cls,
               a: float,
               c: float,
               unit_cell: List[Tuple[Atom, np.ndarray]],
               orientation: Optional[np.ndarray] = None,
               rotation: Optional[np.ndarray] = None,
               size: Optional[Tuple[int, int, int]] = None) -&gt; &#39;Crystal&#39;:
    &#34;&#34;&#34;Initializes a `Crystal` with tetragonal constraints.
    
    Raises:
        `atompack.error.InvalidTetragonalError`: Tetragonal constraints are not satisfied.
    &#34;&#34;&#34;
    b = a
    alpha, beta, gamma = np.pi / 2, np.pi / 2, np.pi / 2
    if a == c:
        raise InvalidTetragonalError(a, b, c, alpha, beta, gamma)
    return cls(a, b, c, alpha, beta, gamma, unit_cell, orientation, rotation, size)</code></pre>
</details>
</dd>
<dt id="atompack.crystal.Crystal.triclinic"><code class="name flex">
<span>def <span class="ident">triclinic</span></span>(<span>a: float, b: float, c: float, alpha: float, beta: float, gamma: float, unit_cell: List[Tuple[atompack.atom.Atom, numpy.ndarray]], orientation: Union[numpy.ndarray, NoneType] = None, rotation: Union[numpy.ndarray, NoneType] = None, size: Union[Tuple[int, int, int], NoneType] = None) -> <a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a <code><a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></code> with triclinic constraints.</p>
<h2 id="raises">Raises</h2>
<p><code><a title="atompack.error.InvalidTriclinicError" href="error.html#atompack.error.InvalidTriclinicError">InvalidTriclinicError</a></code>: Triclinic constraints are not satisfied.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def triclinic(cls,
              a: float,
              b: float,
              c: float,
              alpha: float,
              beta: float,
              gamma: float,
              unit_cell: List[Tuple[Atom, np.ndarray]],
              orientation: Optional[np.ndarray] = None,
              rotation: Optional[np.ndarray] = None,
              size: Optional[Tuple[int, int, int]] = None) -&gt; &#39;Crystal&#39;:
    &#34;&#34;&#34;Initializes a `Crystal` with triclinic constraints.
    
    Raises:
        `atompack.error.InvalidTriclinicError`: Triclinic constraints are not satisfied.
    &#34;&#34;&#34;
    if not (a != b != c):
        raise InvalidTriclinicError(a, b, c, alpha, beta, gamma)
    if not (alpha != beta != gamma):
        raise InvalidTriclinicError(a, b, c, alpha, beta, gamma)
    return cls(a, b, c, alpha, beta, gamma, unit_cell, orientation, rotation, size)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="atompack.atom.AtomCollection" href="atom.html#atompack.atom.AtomCollection">AtomCollection</a></b></code>:
<ul class="hlist">
<li><code><a title="atompack.atom.AtomCollection.insert" href="atom.html#atompack.atom.AtomCollection.insert">insert</a></code></li>
<li><code><a title="atompack.atom.AtomCollection.remove" href="atom.html#atompack.atom.AtomCollection.remove">remove</a></code></li>
<li><code><a title="atompack.atom.AtomCollection.select" href="atom.html#atompack.atom.AtomCollection.select">select</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="atompack" href="index.html">atompack</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></code></h4>
<ul class="two-column">
<li><code><a title="atompack.crystal.Crystal.cubic" href="#atompack.crystal.Crystal.cubic">cubic</a></code></li>
<li><code><a title="atompack.crystal.Crystal.hexagonal" href="#atompack.crystal.Crystal.hexagonal">hexagonal</a></code></li>
<li><code><a title="atompack.crystal.Crystal.monoclinic" href="#atompack.crystal.Crystal.monoclinic">monoclinic</a></code></li>
<li><code><a title="atompack.crystal.Crystal.orthorhombic" href="#atompack.crystal.Crystal.orthorhombic">orthorhombic</a></code></li>
<li><code><a title="atompack.crystal.Crystal.rhombohedral" href="#atompack.crystal.Crystal.rhombohedral">rhombohedral</a></code></li>
<li><code><a title="atompack.crystal.Crystal.tetragonal" href="#atompack.crystal.Crystal.tetragonal">tetragonal</a></code></li>
<li><code><a title="atompack.crystal.Crystal.triclinic" href="#atompack.crystal.Crystal.triclinic">triclinic</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>