<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>atompack.crystal API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>atompack.crystal</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Any, Dict, List, Optional, Tuple

import numpy as np
from scipy.spatial.transform import Rotation

from _pbc import pbc_nearest_neighbor
from atompack.atom import Atom
from atompack.structure import Structure


def metric_tensor(a: float, b: float, c: float, alpha: float, beta: float, gamma: float) -&gt; np.ndarray:
    return np.array([[a * a, a * b * np.cos(gamma), a * c * np.cos(beta)],
                     [a * b * np.cos(gamma), b * b, b * c * np.cos(alpha)],
                     [a * c * np.cos(beta), b * c * np.cos(alpha), c * c]])


class Crystal(Structure):
    &#34;&#34;&#34;Representation of a crystalline lattice.
    
    Note:
        It is a logical error to mutate any of these attributes because the result of any changes will not be reflected in the shape of the basis or the content of the atoms list.

    Args:
        lattice_data: Atomic data used to initialize atoms at each lattice site.
        lattice_sites: Fractional coordinates of atoms in the lattice.
        a: Length of the x direction.
        b: Length of the y direction.
        c: Length of the z direction.
        alpha: Angle between y and z directions in radians.
        beta: Angle between x and z directions in radians.
        gamma: Angle between x and y directions in radians.
        duplicates: Number of duplications to apply to the finished structure along each direction.
        orientation: 3x3 matrix indicating the alignment of the lattice vectors.

    Example:
        &gt;&gt;&gt; from atompack.crystal import Crystal
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt;
        &gt;&gt;&gt; lattice_data = [{&#34;symbol&#34;: &#34;Cr&#34;, &#34;magmom&#34;: 1.0}, {&#34;symbol&#34;: &#34;Cr&#34;, &#34;magmom&#34;: -1.0}]
        &gt;&gt;&gt; lattice_sites = np.array([[0.0, 0.0, 0.0], [0.5, 0.5, 0.5]])
        &gt;&gt;&gt; a = b = c = 2.85
        &gt;&gt;&gt; alpha = beta = gamma = np.pi / 2
        &gt;&gt;&gt; crystal = Crystal(lattice_data, lattice_sites, a, b, c, alpha, beta, gamma)
        &gt;&gt;&gt;
        &gt;&gt;&gt; assert np.allclose(crystal[0].position, np.array([0.0, 0.0, 0.0]))
        &gt;&gt;&gt; assert np.allclose(crystal[1].position, np.array([1.425, 1.425, 1.425]))
    &#34;&#34;&#34;

    def __init__(
            self,
            lattice_data: List[Dict[str, Any]],
            lattice_sites: np.ndarray,
            a: float,
            b: float,
            c: float,
            alpha: float,
            beta: float,
            gamma: float,
            duplicates: Optional[Tuple[int, int, int]] = None,
            orientation: Optional[np.ndarray] = None,
            pbc: Optional[Tuple[bool, bool, bool]] = None,
            tolerance: float = 1.0e-6,
    ) -&gt; None:
        if duplicates is None:
            duplicates = (1, 1, 1)
        if orientation is None:
            orientation = np.identity(3)
        if pbc is None:
            pbc = (False, False, False)
        atoms, basis = self._build(lattice_data, lattice_sites, a, b, c, alpha, beta, gamma, duplicates, orientation,
                                   pbc, tolerance)
        super().__init__(atoms, basis, pbc, tolerance)

    @classmethod
    def triclinic(
            cls,
            lattice_data: List[Dict[str, Any]],
            lattice_sites: np.ndarray,
            a: float,
            b: float,
            c: float,
            alpha: float,
            beta: float,
            gamma: float,
            duplicates: Optional[Tuple[int, int, int]] = None,
            orientation: Optional[np.ndarray] = None,
            pbc: Optional[Tuple[bool, bool, bool]] = None,
            tolerance: float = 1.0e-6,
    ) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes a crystal with triclinic constraints.
        
        a != b != c

        alpha != beta != gamma
        &#34;&#34;&#34;
        return cls(lattice_data, lattice_sites, a, b, c, alpha, beta, gamma, duplicates, orientation, pbc, tolerance)

    @classmethod
    def monoclinic(
            cls,
            lattice_data: List[Dict[str, Any]],
            lattice_sites: np.ndarray,
            a: float,
            b: float,
            c: float,
            beta: float,
            duplicates: Optional[Tuple[int, int, int]] = None,
            orientation: Optional[np.ndarray] = None,
            pbc: Optional[Tuple[bool, bool, bool]] = None,
            tolerance: float = 1.0e-6,
    ) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes a crystal with monoclinic constraints.
        
        a != b != c
        
        alpha == gamma == pi/2
        
        beta != pi / 2
        &#34;&#34;&#34;
        alpha = gamma = np.pi / 2
        return cls(lattice_data, lattice_sites, a, b, c, alpha, beta, gamma, duplicates, orientation, pbc, tolerance)

    @classmethod
    def orthorhombic(
            cls,
            lattice_data: List[Dict[str, Any]],
            lattice_sites: np.ndarray,
            a: float,
            b: float,
            c: float,
            duplicates: Optional[Tuple[int, int, int]] = None,
            orientation: Optional[np.ndarray] = None,
            pbc: Optional[Tuple[bool, bool, bool]] = None,
            tolerance: float = 1.0e-6,
    ) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes a crystal with orthorhombic constraints.
        
        a != b != c
        
        alpha == beta == gamma == pi / 2
        &#34;&#34;&#34;
        alpha = beta = gamma = np.pi / 2
        return cls(lattice_data, lattice_sites, a, b, c, alpha, beta, gamma, duplicates, orientation, pbc, tolerance)

    @classmethod
    def tetragonal(
            cls,
            lattice_data: List[Dict[str, Any]],
            lattice_sites: np.ndarray,
            a: float,
            c: float,
            duplicates: Optional[Tuple[int, int, int]] = None,
            orientation: Optional[np.ndarray] = None,
            pbc: Optional[Tuple[bool, bool, bool]] = None,
            tolerance: float = 1.0e-6,
    ) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes a crystal with tetragonal constraints.
        
        a == b != c
        
        alpha == beta == gamma == pi / 2
        &#34;&#34;&#34;
        b = a
        alpha = beta = gamma = np.pi / 2
        return cls(lattice_data, lattice_sites, a, b, c, alpha, beta, gamma, duplicates, orientation, pbc, tolerance)

    @classmethod
    def rhombohedral(
            cls,
            lattice_data: List[Dict[str, Any]],
            lattice_sites: np.ndarray,
            a: float,
            alpha: float,
            duplicates: Optional[Tuple[int, int, int]] = None,
            orientation: Optional[np.ndarray] = None,
            pbc: Optional[Tuple[bool, bool, bool]] = None,
            tolerance: float = 1.0e-6,
    ) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes a crystal with rhombohedral constraints.
        
        a == b == c
        
        alpha == beta == gamma != pi / 2
        &#34;&#34;&#34;
        b = c = a
        beta = gamma = alpha
        return cls(lattice_data, lattice_sites, a, b, c, alpha, beta, gamma, duplicates, orientation, pbc, tolerance)

    @classmethod
    def hexagonal(
            cls,
            lattice_data: List[Dict[str, Any]],
            lattice_sites: np.ndarray,
            a: float,
            c: float,
            duplicates: Optional[Tuple[int, int, int]] = None,
            orientation: Optional[np.ndarray] = None,
            pbc: Optional[Tuple[bool, bool, bool]] = None,
            tolerance: float = 1.0e-6,
    ) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes a crystal with hexagonal constraints.
        
        a == b != c
        
        alpha == beta == pi / 2
        
        gamma == 2 * pi / 3
        &#34;&#34;&#34;
        b = a
        alpha = beta = np.pi / 2
        gamma = 2 * np.pi / 3
        return cls(lattice_data, lattice_sites, a, b, c, alpha, beta, gamma, duplicates, orientation, pbc, tolerance)

    @classmethod
    def cubic(
            cls,
            lattice_data: List[Dict[str, Any]],
            lattice_sites: np.ndarray,
            a: float,
            duplicates: Optional[Tuple[int, int, int]] = None,
            orientation: Optional[np.ndarray] = None,
            pbc: Optional[Tuple[bool, bool, bool]] = None,
            tolerance: float = 1.0e-6,
    ) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes a crystal with cubic constraints.
        
        a == b == c
        
        alpha == beta == gamma == pi / 2
        &#34;&#34;&#34;
        b = c = a
        alpha = beta = gamma = np.pi / 2
        return cls(lattice_data, lattice_sites, a, b, c, alpha, beta, gamma, duplicates, orientation, pbc, tolerance)

    # TODO: Make a C extension to do this.
    @staticmethod
    def _build(
            lattice_data: List[Dict[str, Any]],
            lattice_sites: np.ndarray,
            a: float,
            b: float,
            c: float,
            alpha: float,
            beta: float,
            gamma: float,
            duplicates: Tuple[int, int, int],
            orientation: np.ndarray,
            pbc: Tuple[bool, bool, bool],
            tolerance: float,
    ) -&gt; Tuple[List[Atom], np.ndarray]:
        &#34;&#34;&#34;Construct a crystalline lattice and populate it with atoms.&#34;&#34;&#34;
        # calculate lattice vectors from metric tensor
        lattice_vectors = np.sqrt(metric_tensor(a, b, c, alpha, beta, gamma))

        # calculate the magnitude of each lattice vector
        lattice_vectors_magnitude = np.linalg.norm(lattice_vectors, axis=0)

        # calculate the unit vector of each lattice vector
        lattice_vectors_hat = lattice_vectors / lattice_vectors_magnitude

        # calculate rotation matrix between natural orientation and desired orientation
        rotation = Rotation.align_vectors(lattice_vectors_hat, orientation)[0]

        # align the lattice vectors with the desired orientation by applying the
        lattice_vectors_oriented = np.matmul(orientation, lattice_vectors)

        # use QR decomposition to calculate an orthogonal representation of the oriented lattice vectors
        _, r = np.linalg.qr(lattice_vectors_oriented.T)
        lattice_vectors_oriented = np.abs(r) * np.array(duplicates)
        lattice_vectors_oriented_magnitude = np.linalg.norm(lattice_vectors_oriented, axis=0)

        # determine smallest possible size
        minimum_orthogonal_size = np.ceil(
            lattice_vectors_oriented_magnitude / lattice_vectors_magnitude) * np.array(duplicates)
        minimum_orthogonal_size = minimum_orthogonal_size.astype(int)

        atoms: List[Atom] = []
        for xsize in range(minimum_orthogonal_size[0]):
            for ysize in range(minimum_orthogonal_size[1]):
                for zsize in range(minimum_orthogonal_size[2]):
                    offset = np.matmul(np.array([xsize, ysize, zsize]), lattice_vectors)
                    for data, site in zip(lattice_data, lattice_sites):

                        # assign the cartesian position
                        position = np.matmul(site, lattice_vectors) + offset
                        position = rotation.apply(position)

                        # transform the position back into the bounding box
                        for i in range(3):
                            if position[i] &lt; -tolerance:
                                new_position = position[i]
                                while new_position &lt; -tolerance:
                                    new_position += lattice_vectors_oriented_magnitude[i]
                                position[i] = new_position
                            elif position[i] &gt;= lattice_vectors_oriented_magnitude[i] - tolerance:
                                new_position = position[i]
                                while new_position &gt;= lattice_vectors_oriented_magnitude[i] - tolerance:
                                    new_position -= lattice_vectors_oriented_magnitude[i]
                                position[i] = new_position

                        # accept the atom if the position is not occupied
                        positions = np.array([atom.position for atom in atoms])
                        distance, _ = pbc_nearest_neighbor(position, positions, lattice_vectors_oriented, pbc)
                        if distance &gt; tolerance:
                            atom = Atom(position=position, **data)
                            atoms.append(atom)

        return atoms, lattice_vectors_oriented</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="atompack.crystal.metric_tensor"><code class="name flex">
<span>def <span class="ident">metric_tensor</span></span>(<span>a: float, b: float, c: float, alpha: float, beta: float, gamma: float) -> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def metric_tensor(a: float, b: float, c: float, alpha: float, beta: float, gamma: float) -&gt; np.ndarray:
    return np.array([[a * a, a * b * np.cos(gamma), a * c * np.cos(beta)],
                     [a * b * np.cos(gamma), b * b, b * c * np.cos(alpha)],
                     [a * c * np.cos(beta), b * c * np.cos(alpha), c * c]])</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="atompack.crystal.Crystal"><code class="flex name class">
<span>class <span class="ident">Crystal</span></span>
<span>(</span><span>lattice_data: List[Dict[str, Any]], lattice_sites: numpy.ndarray, a: float, b: float, c: float, alpha: float, beta: float, gamma: float, duplicates: Union[Tuple[int, int, int], NoneType] = None, orientation: Union[numpy.ndarray, NoneType] = None, pbc: Union[Tuple[bool, bool, bool], NoneType] = None, tolerance: float = 1e-06)</span>
</code></dt>
<dd>
<div class="desc"><p>Representation of a crystalline lattice.</p>
<h2 id="note">Note</h2>
<p>It is a logical error to mutate any of these attributes because the result of any changes will not be reflected in the shape of the basis or the content of the atoms list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lattice_data</code></strong></dt>
<dd>Atomic data used to initialize atoms at each lattice site.</dd>
<dt><strong><code>lattice_sites</code></strong></dt>
<dd>Fractional coordinates of atoms in the lattice.</dd>
<dt><strong><code>a</code></strong></dt>
<dd>Length of the x direction.</dd>
<dt><strong><code>b</code></strong></dt>
<dd>Length of the y direction.</dd>
<dt><strong><code>c</code></strong></dt>
<dd>Length of the z direction.</dd>
<dt><strong><code>alpha</code></strong></dt>
<dd>Angle between y and z directions in radians.</dd>
<dt><strong><code>beta</code></strong></dt>
<dd>Angle between x and z directions in radians.</dd>
<dt><strong><code>gamma</code></strong></dt>
<dd>Angle between x and y directions in radians.</dd>
<dt><strong><code>duplicates</code></strong></dt>
<dd>Number of duplications to apply to the finished structure along each direction.</dd>
<dt><strong><code>orientation</code></strong></dt>
<dd>3x3 matrix indicating the alignment of the lattice vectors.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="python">&gt;&gt;&gt; from atompack.crystal import Crystal
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt;
&gt;&gt;&gt; lattice_data = [{&quot;symbol&quot;: &quot;Cr&quot;, &quot;magmom&quot;: 1.0}, {&quot;symbol&quot;: &quot;Cr&quot;, &quot;magmom&quot;: -1.0}]
&gt;&gt;&gt; lattice_sites = np.array([[0.0, 0.0, 0.0], [0.5, 0.5, 0.5]])
&gt;&gt;&gt; a = b = c = 2.85
&gt;&gt;&gt; alpha = beta = gamma = np.pi / 2
&gt;&gt;&gt; crystal = Crystal(lattice_data, lattice_sites, a, b, c, alpha, beta, gamma)
&gt;&gt;&gt;
&gt;&gt;&gt; assert np.allclose(crystal[0].position, np.array([0.0, 0.0, 0.0]))
&gt;&gt;&gt; assert np.allclose(crystal[1].position, np.array([1.425, 1.425, 1.425]))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Crystal(Structure):
    &#34;&#34;&#34;Representation of a crystalline lattice.
    
    Note:
        It is a logical error to mutate any of these attributes because the result of any changes will not be reflected in the shape of the basis or the content of the atoms list.

    Args:
        lattice_data: Atomic data used to initialize atoms at each lattice site.
        lattice_sites: Fractional coordinates of atoms in the lattice.
        a: Length of the x direction.
        b: Length of the y direction.
        c: Length of the z direction.
        alpha: Angle between y and z directions in radians.
        beta: Angle between x and z directions in radians.
        gamma: Angle between x and y directions in radians.
        duplicates: Number of duplications to apply to the finished structure along each direction.
        orientation: 3x3 matrix indicating the alignment of the lattice vectors.

    Example:
        &gt;&gt;&gt; from atompack.crystal import Crystal
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt;
        &gt;&gt;&gt; lattice_data = [{&#34;symbol&#34;: &#34;Cr&#34;, &#34;magmom&#34;: 1.0}, {&#34;symbol&#34;: &#34;Cr&#34;, &#34;magmom&#34;: -1.0}]
        &gt;&gt;&gt; lattice_sites = np.array([[0.0, 0.0, 0.0], [0.5, 0.5, 0.5]])
        &gt;&gt;&gt; a = b = c = 2.85
        &gt;&gt;&gt; alpha = beta = gamma = np.pi / 2
        &gt;&gt;&gt; crystal = Crystal(lattice_data, lattice_sites, a, b, c, alpha, beta, gamma)
        &gt;&gt;&gt;
        &gt;&gt;&gt; assert np.allclose(crystal[0].position, np.array([0.0, 0.0, 0.0]))
        &gt;&gt;&gt; assert np.allclose(crystal[1].position, np.array([1.425, 1.425, 1.425]))
    &#34;&#34;&#34;

    def __init__(
            self,
            lattice_data: List[Dict[str, Any]],
            lattice_sites: np.ndarray,
            a: float,
            b: float,
            c: float,
            alpha: float,
            beta: float,
            gamma: float,
            duplicates: Optional[Tuple[int, int, int]] = None,
            orientation: Optional[np.ndarray] = None,
            pbc: Optional[Tuple[bool, bool, bool]] = None,
            tolerance: float = 1.0e-6,
    ) -&gt; None:
        if duplicates is None:
            duplicates = (1, 1, 1)
        if orientation is None:
            orientation = np.identity(3)
        if pbc is None:
            pbc = (False, False, False)
        atoms, basis = self._build(lattice_data, lattice_sites, a, b, c, alpha, beta, gamma, duplicates, orientation,
                                   pbc, tolerance)
        super().__init__(atoms, basis, pbc, tolerance)

    @classmethod
    def triclinic(
            cls,
            lattice_data: List[Dict[str, Any]],
            lattice_sites: np.ndarray,
            a: float,
            b: float,
            c: float,
            alpha: float,
            beta: float,
            gamma: float,
            duplicates: Optional[Tuple[int, int, int]] = None,
            orientation: Optional[np.ndarray] = None,
            pbc: Optional[Tuple[bool, bool, bool]] = None,
            tolerance: float = 1.0e-6,
    ) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes a crystal with triclinic constraints.
        
        a != b != c

        alpha != beta != gamma
        &#34;&#34;&#34;
        return cls(lattice_data, lattice_sites, a, b, c, alpha, beta, gamma, duplicates, orientation, pbc, tolerance)

    @classmethod
    def monoclinic(
            cls,
            lattice_data: List[Dict[str, Any]],
            lattice_sites: np.ndarray,
            a: float,
            b: float,
            c: float,
            beta: float,
            duplicates: Optional[Tuple[int, int, int]] = None,
            orientation: Optional[np.ndarray] = None,
            pbc: Optional[Tuple[bool, bool, bool]] = None,
            tolerance: float = 1.0e-6,
    ) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes a crystal with monoclinic constraints.
        
        a != b != c
        
        alpha == gamma == pi/2
        
        beta != pi / 2
        &#34;&#34;&#34;
        alpha = gamma = np.pi / 2
        return cls(lattice_data, lattice_sites, a, b, c, alpha, beta, gamma, duplicates, orientation, pbc, tolerance)

    @classmethod
    def orthorhombic(
            cls,
            lattice_data: List[Dict[str, Any]],
            lattice_sites: np.ndarray,
            a: float,
            b: float,
            c: float,
            duplicates: Optional[Tuple[int, int, int]] = None,
            orientation: Optional[np.ndarray] = None,
            pbc: Optional[Tuple[bool, bool, bool]] = None,
            tolerance: float = 1.0e-6,
    ) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes a crystal with orthorhombic constraints.
        
        a != b != c
        
        alpha == beta == gamma == pi / 2
        &#34;&#34;&#34;
        alpha = beta = gamma = np.pi / 2
        return cls(lattice_data, lattice_sites, a, b, c, alpha, beta, gamma, duplicates, orientation, pbc, tolerance)

    @classmethod
    def tetragonal(
            cls,
            lattice_data: List[Dict[str, Any]],
            lattice_sites: np.ndarray,
            a: float,
            c: float,
            duplicates: Optional[Tuple[int, int, int]] = None,
            orientation: Optional[np.ndarray] = None,
            pbc: Optional[Tuple[bool, bool, bool]] = None,
            tolerance: float = 1.0e-6,
    ) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes a crystal with tetragonal constraints.
        
        a == b != c
        
        alpha == beta == gamma == pi / 2
        &#34;&#34;&#34;
        b = a
        alpha = beta = gamma = np.pi / 2
        return cls(lattice_data, lattice_sites, a, b, c, alpha, beta, gamma, duplicates, orientation, pbc, tolerance)

    @classmethod
    def rhombohedral(
            cls,
            lattice_data: List[Dict[str, Any]],
            lattice_sites: np.ndarray,
            a: float,
            alpha: float,
            duplicates: Optional[Tuple[int, int, int]] = None,
            orientation: Optional[np.ndarray] = None,
            pbc: Optional[Tuple[bool, bool, bool]] = None,
            tolerance: float = 1.0e-6,
    ) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes a crystal with rhombohedral constraints.
        
        a == b == c
        
        alpha == beta == gamma != pi / 2
        &#34;&#34;&#34;
        b = c = a
        beta = gamma = alpha
        return cls(lattice_data, lattice_sites, a, b, c, alpha, beta, gamma, duplicates, orientation, pbc, tolerance)

    @classmethod
    def hexagonal(
            cls,
            lattice_data: List[Dict[str, Any]],
            lattice_sites: np.ndarray,
            a: float,
            c: float,
            duplicates: Optional[Tuple[int, int, int]] = None,
            orientation: Optional[np.ndarray] = None,
            pbc: Optional[Tuple[bool, bool, bool]] = None,
            tolerance: float = 1.0e-6,
    ) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes a crystal with hexagonal constraints.
        
        a == b != c
        
        alpha == beta == pi / 2
        
        gamma == 2 * pi / 3
        &#34;&#34;&#34;
        b = a
        alpha = beta = np.pi / 2
        gamma = 2 * np.pi / 3
        return cls(lattice_data, lattice_sites, a, b, c, alpha, beta, gamma, duplicates, orientation, pbc, tolerance)

    @classmethod
    def cubic(
            cls,
            lattice_data: List[Dict[str, Any]],
            lattice_sites: np.ndarray,
            a: float,
            duplicates: Optional[Tuple[int, int, int]] = None,
            orientation: Optional[np.ndarray] = None,
            pbc: Optional[Tuple[bool, bool, bool]] = None,
            tolerance: float = 1.0e-6,
    ) -&gt; &#39;Crystal&#39;:
        &#34;&#34;&#34;Initializes a crystal with cubic constraints.
        
        a == b == c
        
        alpha == beta == gamma == pi / 2
        &#34;&#34;&#34;
        b = c = a
        alpha = beta = gamma = np.pi / 2
        return cls(lattice_data, lattice_sites, a, b, c, alpha, beta, gamma, duplicates, orientation, pbc, tolerance)

    # TODO: Make a C extension to do this.
    @staticmethod
    def _build(
            lattice_data: List[Dict[str, Any]],
            lattice_sites: np.ndarray,
            a: float,
            b: float,
            c: float,
            alpha: float,
            beta: float,
            gamma: float,
            duplicates: Tuple[int, int, int],
            orientation: np.ndarray,
            pbc: Tuple[bool, bool, bool],
            tolerance: float,
    ) -&gt; Tuple[List[Atom], np.ndarray]:
        &#34;&#34;&#34;Construct a crystalline lattice and populate it with atoms.&#34;&#34;&#34;
        # calculate lattice vectors from metric tensor
        lattice_vectors = np.sqrt(metric_tensor(a, b, c, alpha, beta, gamma))

        # calculate the magnitude of each lattice vector
        lattice_vectors_magnitude = np.linalg.norm(lattice_vectors, axis=0)

        # calculate the unit vector of each lattice vector
        lattice_vectors_hat = lattice_vectors / lattice_vectors_magnitude

        # calculate rotation matrix between natural orientation and desired orientation
        rotation = Rotation.align_vectors(lattice_vectors_hat, orientation)[0]

        # align the lattice vectors with the desired orientation by applying the
        lattice_vectors_oriented = np.matmul(orientation, lattice_vectors)

        # use QR decomposition to calculate an orthogonal representation of the oriented lattice vectors
        _, r = np.linalg.qr(lattice_vectors_oriented.T)
        lattice_vectors_oriented = np.abs(r) * np.array(duplicates)
        lattice_vectors_oriented_magnitude = np.linalg.norm(lattice_vectors_oriented, axis=0)

        # determine smallest possible size
        minimum_orthogonal_size = np.ceil(
            lattice_vectors_oriented_magnitude / lattice_vectors_magnitude) * np.array(duplicates)
        minimum_orthogonal_size = minimum_orthogonal_size.astype(int)

        atoms: List[Atom] = []
        for xsize in range(minimum_orthogonal_size[0]):
            for ysize in range(minimum_orthogonal_size[1]):
                for zsize in range(minimum_orthogonal_size[2]):
                    offset = np.matmul(np.array([xsize, ysize, zsize]), lattice_vectors)
                    for data, site in zip(lattice_data, lattice_sites):

                        # assign the cartesian position
                        position = np.matmul(site, lattice_vectors) + offset
                        position = rotation.apply(position)

                        # transform the position back into the bounding box
                        for i in range(3):
                            if position[i] &lt; -tolerance:
                                new_position = position[i]
                                while new_position &lt; -tolerance:
                                    new_position += lattice_vectors_oriented_magnitude[i]
                                position[i] = new_position
                            elif position[i] &gt;= lattice_vectors_oriented_magnitude[i] - tolerance:
                                new_position = position[i]
                                while new_position &gt;= lattice_vectors_oriented_magnitude[i] - tolerance:
                                    new_position -= lattice_vectors_oriented_magnitude[i]
                                position[i] = new_position

                        # accept the atom if the position is not occupied
                        positions = np.array([atom.position for atom in atoms])
                        distance, _ = pbc_nearest_neighbor(position, positions, lattice_vectors_oriented, pbc)
                        if distance &gt; tolerance:
                            atom = Atom(position=position, **data)
                            atoms.append(atom)

        return atoms, lattice_vectors_oriented</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="atompack.structure.Structure" href="structure.html#atompack.structure.Structure">Structure</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="atompack.crystal.Crystal.cubic"><code class="name flex">
<span>def <span class="ident">cubic</span></span>(<span>lattice_data: List[Dict[str, Any]], lattice_sites: numpy.ndarray, a: float, duplicates: Union[Tuple[int, int, int], NoneType] = None, orientation: Union[numpy.ndarray, NoneType] = None, pbc: Union[Tuple[bool, bool, bool], NoneType] = None, tolerance: float = 1e-06) -> <a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a crystal with cubic constraints.</p>
<p>a == b == c</p>
<p>alpha == beta == gamma == pi / 2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def cubic(
        cls,
        lattice_data: List[Dict[str, Any]],
        lattice_sites: np.ndarray,
        a: float,
        duplicates: Optional[Tuple[int, int, int]] = None,
        orientation: Optional[np.ndarray] = None,
        pbc: Optional[Tuple[bool, bool, bool]] = None,
        tolerance: float = 1.0e-6,
) -&gt; &#39;Crystal&#39;:
    &#34;&#34;&#34;Initializes a crystal with cubic constraints.
    
    a == b == c
    
    alpha == beta == gamma == pi / 2
    &#34;&#34;&#34;
    b = c = a
    alpha = beta = gamma = np.pi / 2
    return cls(lattice_data, lattice_sites, a, b, c, alpha, beta, gamma, duplicates, orientation, pbc, tolerance)</code></pre>
</details>
</dd>
<dt id="atompack.crystal.Crystal.hexagonal"><code class="name flex">
<span>def <span class="ident">hexagonal</span></span>(<span>lattice_data: List[Dict[str, Any]], lattice_sites: numpy.ndarray, a: float, c: float, duplicates: Union[Tuple[int, int, int], NoneType] = None, orientation: Union[numpy.ndarray, NoneType] = None, pbc: Union[Tuple[bool, bool, bool], NoneType] = None, tolerance: float = 1e-06) -> <a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a crystal with hexagonal constraints.</p>
<p>a == b != c</p>
<p>alpha == beta == pi / 2</p>
<p>gamma == 2 * pi / 3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def hexagonal(
        cls,
        lattice_data: List[Dict[str, Any]],
        lattice_sites: np.ndarray,
        a: float,
        c: float,
        duplicates: Optional[Tuple[int, int, int]] = None,
        orientation: Optional[np.ndarray] = None,
        pbc: Optional[Tuple[bool, bool, bool]] = None,
        tolerance: float = 1.0e-6,
) -&gt; &#39;Crystal&#39;:
    &#34;&#34;&#34;Initializes a crystal with hexagonal constraints.
    
    a == b != c
    
    alpha == beta == pi / 2
    
    gamma == 2 * pi / 3
    &#34;&#34;&#34;
    b = a
    alpha = beta = np.pi / 2
    gamma = 2 * np.pi / 3
    return cls(lattice_data, lattice_sites, a, b, c, alpha, beta, gamma, duplicates, orientation, pbc, tolerance)</code></pre>
</details>
</dd>
<dt id="atompack.crystal.Crystal.monoclinic"><code class="name flex">
<span>def <span class="ident">monoclinic</span></span>(<span>lattice_data: List[Dict[str, Any]], lattice_sites: numpy.ndarray, a: float, b: float, c: float, beta: float, duplicates: Union[Tuple[int, int, int], NoneType] = None, orientation: Union[numpy.ndarray, NoneType] = None, pbc: Union[Tuple[bool, bool, bool], NoneType] = None, tolerance: float = 1e-06) -> <a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a crystal with monoclinic constraints.</p>
<p>a != b != c</p>
<p>alpha == gamma == pi/2</p>
<p>beta != pi / 2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def monoclinic(
        cls,
        lattice_data: List[Dict[str, Any]],
        lattice_sites: np.ndarray,
        a: float,
        b: float,
        c: float,
        beta: float,
        duplicates: Optional[Tuple[int, int, int]] = None,
        orientation: Optional[np.ndarray] = None,
        pbc: Optional[Tuple[bool, bool, bool]] = None,
        tolerance: float = 1.0e-6,
) -&gt; &#39;Crystal&#39;:
    &#34;&#34;&#34;Initializes a crystal with monoclinic constraints.
    
    a != b != c
    
    alpha == gamma == pi/2
    
    beta != pi / 2
    &#34;&#34;&#34;
    alpha = gamma = np.pi / 2
    return cls(lattice_data, lattice_sites, a, b, c, alpha, beta, gamma, duplicates, orientation, pbc, tolerance)</code></pre>
</details>
</dd>
<dt id="atompack.crystal.Crystal.orthorhombic"><code class="name flex">
<span>def <span class="ident">orthorhombic</span></span>(<span>lattice_data: List[Dict[str, Any]], lattice_sites: numpy.ndarray, a: float, b: float, c: float, duplicates: Union[Tuple[int, int, int], NoneType] = None, orientation: Union[numpy.ndarray, NoneType] = None, pbc: Union[Tuple[bool, bool, bool], NoneType] = None, tolerance: float = 1e-06) -> <a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a crystal with orthorhombic constraints.</p>
<p>a != b != c</p>
<p>alpha == beta == gamma == pi / 2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def orthorhombic(
        cls,
        lattice_data: List[Dict[str, Any]],
        lattice_sites: np.ndarray,
        a: float,
        b: float,
        c: float,
        duplicates: Optional[Tuple[int, int, int]] = None,
        orientation: Optional[np.ndarray] = None,
        pbc: Optional[Tuple[bool, bool, bool]] = None,
        tolerance: float = 1.0e-6,
) -&gt; &#39;Crystal&#39;:
    &#34;&#34;&#34;Initializes a crystal with orthorhombic constraints.
    
    a != b != c
    
    alpha == beta == gamma == pi / 2
    &#34;&#34;&#34;
    alpha = beta = gamma = np.pi / 2
    return cls(lattice_data, lattice_sites, a, b, c, alpha, beta, gamma, duplicates, orientation, pbc, tolerance)</code></pre>
</details>
</dd>
<dt id="atompack.crystal.Crystal.rhombohedral"><code class="name flex">
<span>def <span class="ident">rhombohedral</span></span>(<span>lattice_data: List[Dict[str, Any]], lattice_sites: numpy.ndarray, a: float, alpha: float, duplicates: Union[Tuple[int, int, int], NoneType] = None, orientation: Union[numpy.ndarray, NoneType] = None, pbc: Union[Tuple[bool, bool, bool], NoneType] = None, tolerance: float = 1e-06) -> <a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a crystal with rhombohedral constraints.</p>
<p>a == b == c</p>
<p>alpha == beta == gamma != pi / 2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def rhombohedral(
        cls,
        lattice_data: List[Dict[str, Any]],
        lattice_sites: np.ndarray,
        a: float,
        alpha: float,
        duplicates: Optional[Tuple[int, int, int]] = None,
        orientation: Optional[np.ndarray] = None,
        pbc: Optional[Tuple[bool, bool, bool]] = None,
        tolerance: float = 1.0e-6,
) -&gt; &#39;Crystal&#39;:
    &#34;&#34;&#34;Initializes a crystal with rhombohedral constraints.
    
    a == b == c
    
    alpha == beta == gamma != pi / 2
    &#34;&#34;&#34;
    b = c = a
    beta = gamma = alpha
    return cls(lattice_data, lattice_sites, a, b, c, alpha, beta, gamma, duplicates, orientation, pbc, tolerance)</code></pre>
</details>
</dd>
<dt id="atompack.crystal.Crystal.tetragonal"><code class="name flex">
<span>def <span class="ident">tetragonal</span></span>(<span>lattice_data: List[Dict[str, Any]], lattice_sites: numpy.ndarray, a: float, c: float, duplicates: Union[Tuple[int, int, int], NoneType] = None, orientation: Union[numpy.ndarray, NoneType] = None, pbc: Union[Tuple[bool, bool, bool], NoneType] = None, tolerance: float = 1e-06) -> <a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a crystal with tetragonal constraints.</p>
<p>a == b != c</p>
<p>alpha == beta == gamma == pi / 2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def tetragonal(
        cls,
        lattice_data: List[Dict[str, Any]],
        lattice_sites: np.ndarray,
        a: float,
        c: float,
        duplicates: Optional[Tuple[int, int, int]] = None,
        orientation: Optional[np.ndarray] = None,
        pbc: Optional[Tuple[bool, bool, bool]] = None,
        tolerance: float = 1.0e-6,
) -&gt; &#39;Crystal&#39;:
    &#34;&#34;&#34;Initializes a crystal with tetragonal constraints.
    
    a == b != c
    
    alpha == beta == gamma == pi / 2
    &#34;&#34;&#34;
    b = a
    alpha = beta = gamma = np.pi / 2
    return cls(lattice_data, lattice_sites, a, b, c, alpha, beta, gamma, duplicates, orientation, pbc, tolerance)</code></pre>
</details>
</dd>
<dt id="atompack.crystal.Crystal.triclinic"><code class="name flex">
<span>def <span class="ident">triclinic</span></span>(<span>lattice_data: List[Dict[str, Any]], lattice_sites: numpy.ndarray, a: float, b: float, c: float, alpha: float, beta: float, gamma: float, duplicates: Union[Tuple[int, int, int], NoneType] = None, orientation: Union[numpy.ndarray, NoneType] = None, pbc: Union[Tuple[bool, bool, bool], NoneType] = None, tolerance: float = 1e-06) -> <a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a crystal with triclinic constraints.</p>
<p>a != b != c</p>
<p>alpha != beta != gamma</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def triclinic(
        cls,
        lattice_data: List[Dict[str, Any]],
        lattice_sites: np.ndarray,
        a: float,
        b: float,
        c: float,
        alpha: float,
        beta: float,
        gamma: float,
        duplicates: Optional[Tuple[int, int, int]] = None,
        orientation: Optional[np.ndarray] = None,
        pbc: Optional[Tuple[bool, bool, bool]] = None,
        tolerance: float = 1.0e-6,
) -&gt; &#39;Crystal&#39;:
    &#34;&#34;&#34;Initializes a crystal with triclinic constraints.
    
    a != b != c

    alpha != beta != gamma
    &#34;&#34;&#34;
    return cls(lattice_data, lattice_sites, a, b, c, alpha, beta, gamma, duplicates, orientation, pbc, tolerance)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="atompack.structure.Structure" href="structure.html#atompack.structure.Structure">Structure</a></b></code>:
<ul class="hlist">
<li><code><a title="atompack.structure.Structure.insert" href="structure.html#atompack.structure.Structure.insert">insert</a></code></li>
<li><code><a title="atompack.structure.Structure.remove" href="structure.html#atompack.structure.Structure.remove">remove</a></code></li>
<li><code><a title="atompack.structure.Structure.select" href="structure.html#atompack.structure.Structure.select">select</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="atompack" href="index.html">atompack</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="atompack.crystal.metric_tensor" href="#atompack.crystal.metric_tensor">metric_tensor</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="atompack.crystal.Crystal" href="#atompack.crystal.Crystal">Crystal</a></code></h4>
<ul class="two-column">
<li><code><a title="atompack.crystal.Crystal.cubic" href="#atompack.crystal.Crystal.cubic">cubic</a></code></li>
<li><code><a title="atompack.crystal.Crystal.hexagonal" href="#atompack.crystal.Crystal.hexagonal">hexagonal</a></code></li>
<li><code><a title="atompack.crystal.Crystal.monoclinic" href="#atompack.crystal.Crystal.monoclinic">monoclinic</a></code></li>
<li><code><a title="atompack.crystal.Crystal.orthorhombic" href="#atompack.crystal.Crystal.orthorhombic">orthorhombic</a></code></li>
<li><code><a title="atompack.crystal.Crystal.rhombohedral" href="#atompack.crystal.Crystal.rhombohedral">rhombohedral</a></code></li>
<li><code><a title="atompack.crystal.Crystal.tetragonal" href="#atompack.crystal.Crystal.tetragonal">tetragonal</a></code></li>
<li><code><a title="atompack.crystal.Crystal.triclinic" href="#atompack.crystal.Crystal.triclinic">triclinic</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>